<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/roadmaps/ANALISIS_FASE_2_VS_2.5.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/roadmaps/ANALISIS_FASE_2_VS_2.5.md" />
              <option name="updatedContent" value="#  ANÁLISIS COMPARATIVO: FASE 2 (POO) vs FASE 2.5 (MovementManager)&#10;&#10;&gt; **Fecha de análisis:** 2025-10-28&#10;&gt; **Objetivo:** Verificar si hay saltos bruscos o temas sin profundizar entre Fase 2 y Fase 2.5&#10;&#10;---&#10;&#10;##  RESUMEN EJECUTIVO&#10;&#10;### ✅ **CONCLUSIÓN GENERAL: LA TRANSICIÓN ES SÓLIDA**&#10;&#10;La Fase 2.5 NO presenta saltos bruscos significativos. Es una **extensión natural y bien estructurada** de la Fase 2 que aplica los conceptos aprendidos en un contexto más profesional.&#10;&#10;**Puntos fuertes:**&#10;- ✅ Reutiliza conceptos ya aprendidos en Fase 2&#10;- ✅ Introduce patrón Manager de forma gradual&#10;- ✅ Mantiene el mismo estilo pedagógico (TÚ escribes el código)&#10;- ✅ Estructura coherente con checkpoints claros&#10;&#10;**Áreas de oportunidad identificadas:**&#10;- ⚠️ Falta explicar mejor **por qué `List&lt;T&gt;` como tipo, `ArrayList&lt;&gt;` como implementación**&#10;- ⚠️ No se menciona que en Fase 2.6 ya trabajaron con ArrayList en Main.java&#10;- ⚠️ Falta conectar explícitamente con el aprendizaje previo de ArrayList&#10;&#10;---&#10;&#10;##  ANÁLISIS DETALLADO POR CONCEPTO&#10;&#10;### 1️⃣ **PREREQUISITOS DE FASE 2 QUE SE ASUMEN EN FASE 2.5**&#10;&#10;| Concepto de Fase 2 | ¿Se usa en Fase 2.5? | ¿Se explica nuevamente? | Evaluación |&#10;|---------------------|----------------------|-------------------------|------------|&#10;| Clases y objetos | ✅ Sí | ✅ Sí (brevemente) | ✅ Bien |&#10;| Constructores | ✅ Sí | ✅ Sí (con analogía) | ✅ Bien |&#10;| Encapsulamiento (private) | ✅ Sí | ✅ Sí (explicado en atributo) | ✅ Bien |&#10;| Getters/Setters | ✅ Sí | ❌ Solo se menciona | ⚠️ Asumir que se domina |&#10;| toString() | ❌ No se usa | ❌ No relevante | ✅ OK |&#10;| ArrayList&lt;T&gt; | ✅ SÍ (CRÍTICO) | ⚠️ Parcialmente | ⚠️ **BRECHA IDENTIFICADA** |&#10;| For-each loop | ✅ Sí | ✅ Sí (con sintaxis) | ✅ Bien |&#10;| Comparación con .equals() | ✅ Sí | ✅ Sí (recordatorio) | ✅ Bien |&#10;&#10;---&#10;&#10;### 2️⃣ **BRECHA IDENTIFICADA: ArrayList en Fase 2.6 vs Fase 2.5**&#10;&#10;####  PROBLEMA:&#10;&#10;**En Fase 2 - Checkpoint 2.6:**&#10;```java&#10;// El usuario YA aprendió a:&#10;ArrayList&lt;Movement&gt; movements = new ArrayList&lt;&gt;();&#10;movements.add(entrada1);&#10;movements.add(salida1);&#10;for (Movement m : movements) { ... }&#10;```&#10;&#10;**En Fase 2.5 - Paso 2 (Declarar atributo):**&#10;```java&#10;// Se pide declarar:&#10;private List&lt;Movement&gt; movements;&#10;&#10;// PERO no se explica por qué es List&lt;&gt; y no ArrayList&lt;&gt;&#10;```&#10;&#10;#### ⚠️ PROBLEMA PEDAGÓGICO:&#10;&#10;El estudiante aprendió en Fase 2.6:&#10;```java&#10;ArrayList&lt;Movement&gt; movements = new ArrayList&lt;&gt;();&#10;```&#10;&#10;Ahora en Fase 2.5 se pide:&#10;```java&#10;private List&lt;Movement&gt; movements;  // ¿Por qué cambió a List?&#10;this.movements = new ArrayList&lt;&gt;();  // Ah, ArrayList sigue aquí&#10;```&#10;&#10;**Esta diferencia NO se explica explícitamente.**&#10;&#10;El estudiante puede preguntarse:&#10;- &quot;¿Por qué ahora uso `List` y antes usaba `ArrayList`?&quot;&#10;- &quot;¿Son lo mismo?&quot;&#10;- &quot;¿Cuándo uso uno u otro?&quot;&#10;&#10;---&#10;&#10;### 3️⃣ **CONCEPTOS NUEVOS INTRODUCIDOS EN FASE 2.5**&#10;&#10;| Concepto Nuevo | Complejidad | ¿Se explica bien? | ¿Tiene prerequisitos claros? |&#10;|----------------|-------------|-------------------|------------------------------|&#10;| Patrón Manager/Service | Media | ✅ Excelente (con analogía) | ✅ Sí (requiere POO básica) |&#10;| Paquetes (organización) | Baja | ✅ Bien explicado | ✅ Sí |&#10;| List vs ArrayList (polimorfismo) | Media-Alta | ⚠️ **INSUFICIENTE** | ❌ No se menciona que es polimorfismo |&#10;| Métodos que retornan objetos | Media | ✅ Bien explicado | ✅ Sí (visto en Fase 2) |&#10;| Algoritmo de búsqueda lineal | Media | ✅ Excelente (con pseudocódigo) | ✅ Sí |&#10;| Algoritmo de filtrado | Media | ✅ Excelente (con pseudocódigo) | ✅ Sí |&#10;| Patrón acumulador | Baja | ✅ Bien explicado | ✅ Sí |&#10;| DRY (Don't Repeat Yourself) | Media | ✅ Bien explicado | ✅ Sí |&#10;| Javadoc | Baja | ✅ Bien introducido | ✅ Sí |&#10;&#10;---&#10;&#10;### 4️⃣ **COHERENCIA EN LA ESTRUCTURA PEDAGÓGICA**&#10;&#10;| Aspecto | Fase 2 | Fase 2.5 | Coherencia |&#10;|---------|--------|----------|------------|&#10;| Filosofía &quot;TÚ escribes&quot; | ✅ Sí | ✅ Sí | ✅ Consistente |&#10;| Analogías del mundo real | ✅ Sí (galletas, IKEA) | ✅ Sí (archivador, Jefe de Patio) | ✅ Consistente |&#10;| Preguntas de comprensión | ✅ Sí | ✅ Sí | ✅ Consistente |&#10;| Breakpoints y depuración | ✅ Sí | ✅ Sí | ✅ Consistente |&#10;| Diagramas de tarea | ✅ Sí | ✅ Sí (mejorados) | ✅ Consistente |&#10;| Checkpoints de compilación | ✅ Sí | ✅ Sí | ✅ Consistente |&#10;| Prompts sugeridos | ✅ Sí | ✅ Sí | ✅ Consistente |&#10;&#10;**✅ EVALUACIÓN:** La estructura pedagógica es consistente y mantiene la misma línea educativa.&#10;&#10;---&#10;&#10;### 5️⃣ **PROGRESIÓN DE COMPLEJIDAD**&#10;&#10;#### Fase 2 - Checkpoint 2.6 (ArrayList):&#10;```&#10;Complejidad: ★★☆☆☆ (Baja-Media)&#10;- Crear ArrayList&#10;- Agregar elementos&#10;- Recorrer con for-each&#10;- Buscar PRIMER elemento&#10;- Buscar TODOS los elementos&#10;- Calcular totales&#10;```&#10;&#10;#### Fase 2.5 - MovementManager:&#10;```&#10;Complejidad: ★★★☆☆ (Media)&#10;- Encapsular ArrayList en una clase&#10;- Crear métodos de gestión&#10;- Implementar búsquedas (findById)&#10;- Implementar filtros (getMovementsByType)&#10;- Implementar cálculos agregados&#10;- Aplicar patrón Manager&#10;```&#10;&#10;**✅ EVALUACIÓN:** La progresión es lógica. Fase 2.5 aplica lo aprendido en un contexto más profesional (clase dedicada en vez de código suelto en Main).&#10;&#10;---&#10;&#10;### 6️⃣ **CONEXIONES EXPLÍCITAS ENTRE FASES**&#10;&#10;#### ✅ **Conexiones QUE SÍ existen:**&#10;&#10;1. **Reutilización de Movement:**&#10;   - Fase 2.5 dice: &quot;Debes tener `Movement.java` completo en el paquete `models/`&quot;&#10;   - ✅ Prerequisito claro&#10;&#10;2. **Uso de ArrayList:**&#10;   - Fase 2.5 dice: &quot;Usaremos un `ArrayList`&quot;&#10;   - ✅ Se asume conocimiento previo (correcto, porque se vio en 2.6)&#10;&#10;3. **For-each loop:**&#10;   - Fase 2.5 recuerda la sintaxis: `for (Movement m : movements)`&#10;   - ✅ Repaso adecuado&#10;&#10;4. **Comparación con .equals():**&#10;   - Fase 2.5 recuerda: &quot;Usa .equals() para comparar Strings (NO ==)&quot;&#10;   - ✅ Refuerzo correcto&#10;&#10;#### ⚠️ **Conexiones QUE FALTAN:**&#10;&#10;1. **Referencia explícita a Checkpoint 2.6:**&#10;   - Fase 2.5 NO dice: &quot;En Checkpoint 2.6 ya trabajaste con ArrayList en Main. Ahora vamos a profesionalizar eso creando una clase dedicada.&quot;&#10;   - ⚠️ Falta contexto&#10;&#10;2. **Explicación de List vs ArrayList:**&#10;   - Fase 2.5 NO dice: &quot;Antes declarabas `ArrayList&lt;Movement&gt;`, ahora declaras `List&lt;Movement&gt;` (interfaz) para flexibilidad. En el constructor sigue siendo `new ArrayList&lt;&gt;()`.&quot;&#10;   - ⚠️ Brecha conceptual&#10;&#10;3. **Por qué Manager es mejor que código en Main:**&#10;   - Fase 2.5 SÍ explica esto (con el contraste &quot;Sin Manager&quot; vs &quot;Con Manager&quot;)&#10;   - ✅ Bien explicado&#10;&#10;---&#10;&#10;### 7️⃣ **MÉTODOS DE MOVEMENTMANAGER: ¿HAY SALTOS BRUSCOS?**&#10;&#10;| Método | Concepto Base | ¿Se vio en Fase 2? | ¿Se explica bien en 2.5? |&#10;|--------|---------------|---------------------|--------------------------|&#10;| `addMovement()` | Crear objeto, agregar a lista | ✅ Sí (2.2 y 2.6) | ✅ Sí |&#10;| `getAllMovements()` | Getter simple | ✅ Sí (2.3) | ✅ Sí |&#10;| `findById()` | Búsqueda lineal | ✅ Sí (2.6 - &quot;Buscar PRIMER elemento&quot;) | ✅ Sí (con pseudocódigo) |&#10;| `getMovementsByType()` | Filtrado | ✅ Sí (2.6 - &quot;Buscar TODOS&quot;) | ✅ Sí (con pseudocódigo) |&#10;| `getTotalMovements()` | .size() | ✅ Sí (2.6) | ✅ Sí |&#10;| `calculateTotalEntered()` | Patrón acumulador | ✅ Sí (2.6 - &quot;Calcular total&quot;) | ✅ Sí (con diagrama) |&#10;| `calculateTotalExited()` | Patrón acumulador | ✅ Sí (2.6) | ✅ Sí |&#10;| `getCurrentStock()` | Reutilización de métodos (DRY) | ⚠️ Implícito en 2.3 (getTotalValue) | ✅ Sí (se explica DRY) |&#10;&#10;**✅ EVALUACIÓN:** NO hay saltos bruscos. Todos los métodos aplican conceptos ya vistos o se explican adecuadamente.&#10;&#10;---&#10;&#10;##  TEMAS POTENCIALMENTE SIN PROFUNDIZAR&#10;&#10;### 1. **List vs ArrayList (Polimorfismo básico)**&#10;&#10;**Problema:**&#10;```java&#10;// Fase 2.6 enseñó:&#10;ArrayList&lt;Movement&gt; movements = new ArrayList&lt;&gt;();&#10;&#10;// Fase 2.5 usa:&#10;private List&lt;Movement&gt; movements;&#10;this.movements = new ArrayList&lt;&gt;();&#10;```&#10;&#10;**Por qué es importante:**&#10;- Es un concepto de **polimorfismo** (programar contra interfaz, no implementación)&#10;- Es una **buena práctica profesional**&#10;- Puede confundir al estudiante si no se explica&#10;&#10;**Sugerencia de mejora:**&#10;&#10;En Fase 2.5, PASO 2 (Declarar atributo), agregar:&#10;&#10;```markdown&#10;** Nota importante - List vs ArrayList:**&#10;&#10;En Checkpoint 2.6 usaste:&#10;```java&#10;ArrayList&lt;Movement&gt; movements = new ArrayList&lt;&gt;();&#10;```&#10;&#10;Ahora usas:&#10;```java&#10;private List&lt;Movement&gt; movements;&#10;this.movements = new ArrayList&lt;&gt;();&#10;```&#10;&#10;**¿Cuál es la diferencia?**&#10;&#10;- `List&lt;Movement&gt;`: Es la INTERFAZ (el &quot;qué&quot; - lista de movimientos)&#10;- `ArrayList&lt;Movement&gt;`: Es la IMPLEMENTACIÓN (el &quot;cómo&quot; - usando un arreglo dinámico)&#10;&#10;**Analogía:**&#10;- `List` = &quot;Necesito un vehículo&quot;&#10;- `ArrayList` = &quot;Específicamente un automóvil&quot;&#10;&#10;**¿Por qué hacemos esto?**&#10;- ✅ **Flexibilidad:** Si después quieres usar `LinkedList` en vez de `ArrayList`, solo cambias UNA línea (el constructor)&#10;- ✅ **Buena práctica:** Programar contra interfaces hace el código más mantenible&#10;- ✅ **Profesional:** Así se hace en proyectos reales&#10;&#10;**Regla práctica:**&#10;- **Atributos y parámetros:** Usa la interfaz (`List&lt;Movement&gt;`)&#10;- **Constructor/Instanciación:** Usa la implementación (`new ArrayList&lt;&gt;()`)&#10;&#10;**Pregunta de reflexión:**&#10;¿Por qué no puedes hacer `new List&lt;&gt;()`? Porque las interfaces no se pueden instanciar directamente.&#10;```&#10;&#10;---&#10;&#10;### 2. **Javadoc - Primera aparición sin introducción previa**&#10;&#10;**Problema:**&#10;- Fase 2 NO menciona Javadoc&#10;- Fase 2.5 PASO 4 pide: &quot;TÚ debes escribir el javadoc&quot;&#10;&#10;**Evaluación:**&#10;- ⚠️ El concepto se introduce &quot;on the fly&quot;&#10;- ✅ PERO es un concepto simple (comentarios de documentación)&#10;- ✅ Se da suficiente contexto: &quot;comentario con `/** */` explicando qué hace, qué recibe, qué retorna&quot;&#10;&#10;**Sugerencia:**&#10;No es un problema grave, pero podría mejorarse agregando en PASO 4:&#10;&#10;```markdown&#10;** NUEVO CONCEPTO: Javadoc**&#10;&#10;Javadoc es un tipo especial de comentario que documenta métodos.&#10;&#10;**Diferencias:**&#10;```java&#10;// Comentario normal&#10;/* Comentario de bloque */&#10;/** Comentario Javadoc - Genera documentación automática */&#10;```&#10;&#10;**Estructura básica:**&#10;```java&#10;/**&#10; * Descripción breve de qué hace el método.&#10; * &#10; * @param nombreParametro Qué significa este parámetro&#10; * @return Qué retorna el método&#10; */&#10;public Movement addMovement(...) { ... }&#10;```&#10;&#10;**Beneficio:**&#10;Las IDEs muestran esta documentación cuando usas el método (hover o Ctrl+Q en IntelliJ).&#10;```&#10;&#10;---&#10;&#10;### 3. **Retornar null vs Optional (Mención temprana)**&#10;&#10;**Contexto:**&#10;Fase 2.5 - PASO 6 menciona:&#10;&gt; &quot;Convención Java: `null` indica 'no encontrado' (en Fase 8 aprenderás `Optional&lt;Movement&gt;` como alternativa más segura)&quot;&#10;&#10;**Evaluación:**&#10;- ✅ Es bueno mencionar que existe una alternativa&#10;- ✅ Es correcto NO enseñarla ahora (sobrecarga cognitiva)&#10;- ✅ El paréntesis es adecuado&#10;&#10;**No requiere cambios.**&#10;&#10;---&#10;&#10;### 4. **DRY (Don't Repeat Yourself) - Primera mención**&#10;&#10;**Contexto:**&#10;Fase 2.5 - PASO 9.3 introduce DRY:&#10;&gt; &quot;Reutilización de código (DRY - Don't Repeat Yourself)&quot;&#10;&#10;**Evaluación:**&#10;- ✅ Se explica en contexto (método getCurrentStock que reutiliza otros métodos)&#10;- ✅ Es intuitivo (no duplicar bucles)&#10;- ✅ El acrónimo se define&#10;&#10;**No requiere cambios.**&#10;&#10;---&#10;&#10;##  TABLA COMPARATIVA: COMPLEJIDAD POR CHECKPOINT&#10;&#10;| Checkpoint | Concepto Principal | Complejidad | Prerequisitos | ¿Se cumplen? |&#10;|------------|-------------------|-------------|---------------|--------------|&#10;| **FASE 2** |&#10;| 2.1 | Clases y atributos privados | ★☆☆☆☆ | Ninguno | ✅ |&#10;| 2.2 | Constructores y `this` | ★★☆☆☆ | 2.1 | ✅ |&#10;| 2.3 | Getters/Setters | ★★☆☆☆ | 2.1, 2.2 | ✅ |&#10;| 2.4 | toString() | ★☆☆☆☆ | 2.1, 2.2, 2.3 | ✅ |&#10;| 2.5 | Más clases (Vehicle, etc.) | ★★☆☆☆ | 2.1-2.4 | ✅ |&#10;| 2.6 | ArrayList | ★★★☆☆ | 2.1-2.5 | ✅ |&#10;| **FASE 2.5** |&#10;| 2.5.1 | Crear paquete managers | ★☆☆☆☆ | 2.1-2.5 (organización) | ✅ |&#10;| 2.5.2 | MovementManager (estructura) | ★★☆☆☆ | 2.1-2.6 (especialmente 2.6) | ✅ |&#10;| 2.5.3 | Compilación | ★☆☆☆☆ | 2.5.1, 2.5.2 | ✅ |&#10;| 2.5.4 | Probar en Main | ★★★☆☆ | 2.5.1-2.5.3 | ✅ |&#10;&#10;**✅ CONCLUSIÓN:** La progresión de complejidad es gradual y lógica.&#10;&#10;---&#10;&#10;##  RECOMENDACIONES PARA MEJORAR FASE 2.5&#10;&#10;###  **CAMBIOS SUGERIDOS (Prioridad ALTA)**&#10;&#10;#### 1. Agregar sección al inicio de Fase 2.5:&#10;&#10;```markdown&#10;##  CONEXIÓN CON FASE 2&#10;&#10;### ¿Qué ya sabes?&#10;&#10;En la Fase 2, especialmente en **Checkpoint 2.6**, aprendiste a trabajar con ArrayList&lt;Movement&gt;:&#10;&#10;```java&#10;// Esto ya lo hiciste en Fase 2.6:&#10;ArrayList&lt;Movement&gt; movements = new ArrayList&lt;&gt;();&#10;movements.add(entrada1);&#10;for (Movement m : movements) {&#10;    System.out.println(m);&#10;}&#10;```&#10;&#10;Esto funciona, pero tiene un problema: **el código está suelto en Main.java**.&#10;&#10;### ¿Qué vamos a mejorar en Fase 2.5?&#10;&#10;Vamos a **profesionalizar** ese código creando una clase dedicada:&#10;&#10;**Antes (Fase 2.6 - código suelto):**&#10;```java&#10;// Main.java&#10;ArrayList&lt;Movement&gt; movements = new ArrayList&lt;&gt;();&#10;movements.add(entrada1);&#10;// ... 50 líneas más de lógica de gestión&#10;```&#10;&#10;**Después (Fase 2.5 - código organizado):**&#10;```java&#10;// Main.java&#10;MovementManager manager = new MovementManager();&#10;manager.addMovement(...);&#10;manager.findById(...);&#10;manager.calculateTotalEntered();&#10;```&#10;&#10;**Ventajas:**&#10;- ✅ Main.java queda limpio y legible&#10;- ✅ La lógica de gestión está encapsulada&#10;- ✅ Puedes reutilizar MovementManager en otros lugares&#10;- ✅ Es más fácil de probar y mantener&#10;&#10;### ¿Qué conceptos nuevos aprenderás?&#10;&#10;- **Patrón Manager:** Clase dedicada a gestionar colecciones&#10;- **List vs ArrayList:** Programar contra interfaces (buena práctica)&#10;- **Javadoc:** Documentar métodos profesionalmente&#10;```&#10;&#10;#### 2. En PASO 2 (Declarar atributo), agregar explicación de List vs ArrayList (ver sección 7.1 arriba)&#10;&#10;#### 3. En PASO 4 (addMovement), agregar breve intro a Javadoc (ver sección 7.2 arriba)&#10;&#10;---&#10;&#10;###  **CAMBIOS SUGERIDOS (Prioridad MEDIA)**&#10;&#10;#### 1. Al final de Fase 2.5, agregar sección de reflexión:&#10;&#10;```markdown&#10;##  REFLEXIÓN: ¿QUÉ CAMBIÓ DESDE FASE 2.6?&#10;&#10;### Antes (Fase 2.6):&#10;```java&#10;// Main.java - TODO está aquí&#10;public static void main(String[] args) {&#10;    ArrayList&lt;Movement&gt; movements = new ArrayList&lt;&gt;();&#10;    &#10;    // Agregar movimientos&#10;    Movement m1 = new Movement(&quot;ENTRADA&quot;, &quot;Diesel&quot;, 100, 3.45);&#10;    movements.add(m1);&#10;    &#10;    // Buscar por ID&#10;    Movement found = null;&#10;    for (Movement m : movements) {&#10;        if (m.getId().equals(&quot;buscar&quot;)) {&#10;            found = m;&#10;            break;&#10;        }&#10;    }&#10;    &#10;    // Calcular total&#10;    double total = 0;&#10;    for (Movement m : movements) {&#10;        total += m.getQuantity();&#10;    }&#10;    &#10;    // ... más lógica&#10;}&#10;```&#10;&#10;**Problemas:**&#10;- ❌ Main.java tiene 200+ líneas&#10;- ❌ Lógica de gestión mezclada con lógica de coordinación&#10;- ❌ Código repetitivo (bucles similares en varios lugares)&#10;- ❌ Difícil de testear&#10;&#10;### Después (Fase 2.5):&#10;```java&#10;// Main.java - LIMPIO Y COORDINADOR&#10;public static void main(String[] args) {&#10;    MovementManager manager = new MovementManager();&#10;    manager.addMovement(&quot;ENTRADA&quot;, &quot;Diesel&quot;, 100, 3.45);&#10;    Movement found = manager.findById(&quot;buscar&quot;);&#10;    double total = manager.calculateTotalEntered();&#10;}&#10;&#10;// MovementManager.java - ESPECIALISTA EN GESTIÓN&#10;public class MovementManager {&#10;    private List&lt;Movement&gt; movements;&#10;    &#10;    public Movement findById(String id) {&#10;        for (Movement m : movements) {&#10;            if (m.getId().equals(id)) return m;&#10;        }&#10;        return null;&#10;    }&#10;    // ... más métodos especializados&#10;}&#10;```&#10;&#10;**Ventajas:**&#10;- ✅ Separación de responsabilidades (SRP - Single Responsibility Principle)&#10;- ✅ Código reutilizable (DRY - Don't Repeat Yourself)&#10;- ✅ Fácil de testear (puedes probar MovementManager independientemente)&#10;- ✅ Profesional (así se hace en proyectos reales)&#10;&#10;### Pregunta de autoevaluación:&#10;¿Puedes explicar en tus palabras por qué MovementManager es mejor que tener todo en Main.java?&#10;```&#10;&#10;---&#10;&#10;###  **CAMBIOS SUGERIDOS (Prioridad BAJA - Opcional)**&#10;&#10;#### 1. Agregar diagrama de flujo de llamadas:&#10;&#10;```markdown&#10;##  FLUJO DE INTERACCIÓN&#10;&#10;### Cómo se comunican las clases:&#10;&#10;```&#10;Main.java&#10;    │&#10;    ├─&gt; Llama a MovementManager.addMovement(...)&#10;    │       │&#10;    │       └─&gt; MovementManager crea new Movement(...)&#10;    │               │&#10;    │               └─&gt; Movement se inicializa con constructor&#10;    │                       │&#10;    │                       └─&gt; IdGenerator.generateMovementId()&#10;    │&#10;    ├─&gt; Llama a MovementManager.findById(...)&#10;    │       │&#10;    │       └─&gt; MovementManager recorre la lista&#10;    │               │&#10;    │               └─&gt; Usa Movement.getId() para comparar&#10;    │&#10;    └─&gt; Llama a MovementManager.calculateTotalEntered()&#10;            │&#10;            └─&gt; MovementManager suma usando Movement.getQuantity()&#10;```&#10;&#10;**Observa cómo cada clase tiene su rol:**&#10;- **Main:** Coordina (orquestador)&#10;- **MovementManager:** Gestiona colección (manager)&#10;- **Movement:** Representa datos (modelo)&#10;- **IdGenerator:** Genera IDs (utilidad)&#10;```&#10;&#10;---&#10;&#10;## ✅ CHECKLIST FINAL DE VALIDACIÓN&#10;&#10;### Prerequisitos de Fase 2 que SÍ se respetan en Fase 2.5:&#10;&#10;- [x] Clases y objetos&#10;- [x] Constructores&#10;- [x] Encapsulamiento (private)&#10;- [x] Getters&#10;- [x] For-each loop&#10;- [x] Comparación con .equals()&#10;&#10;### Prerequisitos de Fase 2 que se ASUMEN sin re-explicar:&#10;&#10;- [x] Setters (se usan implícitamente, no crítico)&#10;- [x] toString() (no se usa en MovementManager, OK)&#10;&#10;### Brechas identificadas:&#10;&#10;- [ ] **List vs ArrayList** - Se usa sin explicar la diferencia con lo aprendido en 2.6&#10;- [ ] **Javadoc** - Se introduce sin contexto previo (aunque es simple)&#10;- [ ] **Referencia explícita a Checkpoint 2.6** - Falta enlace directo&#10;&#10;---&#10;&#10;##  CONCLUSIÓN FINAL&#10;&#10;### ✅ **LA FASE 2.5 ES SÓLIDA Y NO PRESENTA SALTOS BRUSCOS GRAVES**&#10;&#10;**Fortalezas:**&#10;1. ✅ Mantiene la filosofía pedagógica de la Fase 2&#10;2. ✅ Progresión de complejidad gradual y lógica&#10;3. ✅ Todos los métodos se basan en conceptos ya vistos&#10;4. ✅ Excelente uso de analogías y diagramas&#10;5. ✅ Estructura clara con checkpoints de compilación&#10;&#10;**Áreas de mejora (NO críticas, pero sí valiosas):**&#10;1. ⚠️ Agregar sección &quot;Conexión con Fase 2&quot; al inicio&#10;2. ⚠️ Explicar la diferencia List vs ArrayList en PASO 2&#10;3. ⚠️ Introducir brevemente Javadoc en PASO 4&#10;&#10;**Calificación de transición:**&#10;- **Sin mejoras:** 8/10 (buena, pero puede confundir levemente)&#10;- **Con mejoras sugeridas:** 10/10 (excelente, sin brechas)&#10;&#10;---&#10;&#10;##  PRÓXIMOS PASOS RECOMENDADOS&#10;&#10;1. **Revisar** las secciones de List vs ArrayList y Javadoc&#10;2. **Agregar** la sección &quot;Conexión con Fase 2&quot; al inicio de Fase 2.5&#10;3. **Validar** que el estudiante entiende la transición con una pregunta de reflexión&#10;4. **Opcional:** Agregar diagrama de flujo de interacción entre clases&#10;&#10;---&#10;&#10;**Documentado por:** Análisis automatizado de roadmaps&#10;**Revisado para:** Garantizar continuidad pedagógica sin saltos bruscos&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/roadmaps/MEJORAS_SUGERIDAS_FASE_2.5.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/roadmaps/MEJORAS_SUGERIDAS_FASE_2.5.md" />
              <option name="updatedContent" value="#  MEJORAS SUGERIDAS PARA FASE 2.5&#10;&#10;&gt; **Fecha:** 2025-10-28&#10;&gt; **Objetivo:** Cerrar brechas identificadas en el análisis comparativo&#10;&#10;---&#10;&#10;##  RESUMEN DE MEJORAS&#10;&#10;Se identificaron **3 áreas de mejora** para fortalecer la transición entre Fase 2 y Fase 2.5:&#10;&#10;1. ✅ **Prioridad ALTA:** Agregar sección &quot;Conexión con Fase 2&quot;&#10;2. ✅ **Prioridad ALTA:** Explicar List vs ArrayList&#10;3. ✅ **Prioridad MEDIA:** Introducir Javadoc adecuadamente&#10;&#10;---&#10;&#10;##  MEJORA #1: Agregar Sección de Conexión (PRIORIDAD ALTA)&#10;&#10;### **Ubicación:** Después de &quot;Antes de empezar&quot;, antes de &quot;¿POR QUÉ NECESITAMOS MovementManager?&quot;&#10;&#10;### **Contenido a insertar:**&#10;&#10;```markdown&#10;---&#10;&#10;##  CONEXIÓN CON FASE 2: De ArrayList en Main a MovementManager&#10;&#10;###  ¿Qué ya dominas?&#10;&#10;En la **Fase 2 - Checkpoint 2.6**, aprendiste a trabajar con ArrayList&lt;Movement&gt; directamente en Main.java:&#10;&#10;```java&#10;// Esto YA lo hiciste en Checkpoint 2.6:&#10;ArrayList&lt;Movement&gt; movements = new ArrayList&lt;&gt;();&#10;movements.add(entrada1);&#10;movements.add(salida1);&#10;&#10;// Recorrer todos&#10;for (Movement m : movements) {&#10;    System.out.println(m);&#10;}&#10;&#10;// Buscar el primero que cumpla condición&#10;Movement primeraEntrada = null;&#10;for (Movement m : movements) {&#10;    if (m.getMovementType().equals(&quot;ENTRADA&quot;)) {&#10;        primeraEntrada = m;&#10;        break;&#10;    }&#10;}&#10;&#10;// Calcular totales&#10;double granTotal = 0;&#10;for (Movement m : movements) {&#10;    granTotal += m.getTotalValue();&#10;}&#10;```&#10;&#10;**Esto funciona perfectamente**, pero tiene limitaciones cuando el proyecto crece:&#10;&#10;### ❌ Problemas del enfoque actual (código en Main.java):&#10;&#10;```&#10;Main.java se convierte en un &quot;Dios&quot; que hace TODO:&#10;│&#10;├── Crear y gestionar la lista de movimientos&#10;├── Lógica de búsqueda (bucles for)&#10;├── Lógica de filtrado (más bucles for)&#10;├── Cálculos agregados (más bucles for)&#10;├── Coordinación de la aplicación&#10;├── Mostrar menús&#10;└── ... 500 líneas de código mezclado &#10;```&#10;&#10;**Resultado:**&#10;- ❌ Main.java de 500+ líneas (difícil de leer y mantener)&#10;- ❌ Lógica de gestión MEZCLADA con lógica de coordinación&#10;- ❌ Código REPETITIVO (bucles similares en múltiples lugares)&#10;- ❌ DIFÍCIL de testear (todo está acoplado a Main)&#10;- ❌ IMPOSIBLE de reutilizar (la lógica está &quot;encerrada&quot; en main())&#10;&#10;### ✅ Solución profesional: Patrón Manager&#10;&#10;En la Fase 2.5 vamos a **profesionalizar** ese código siguiendo el principio de **Separación de Responsabilidades**:&#10;&#10;**Antes (Fase 2.6 - código suelto en Main):**&#10;```java&#10;// Main.java - hace TODO&#10;public static void main(String[] args) {&#10;    ArrayList&lt;Movement&gt; movements = new ArrayList&lt;&gt;();&#10;    &#10;    // Agregar movimiento&#10;    Movement m1 = new Movement(&quot;ENTRADA&quot;, &quot;Diesel&quot;, 100, 3.45);&#10;    movements.add(m1);&#10;    &#10;    // Buscar por ID (15 líneas de código)&#10;    Movement found = null;&#10;    for (Movement m : movements) {&#10;        if (m.getId().equals(idBuscado)) {&#10;            found = m;&#10;            break;&#10;        }&#10;    }&#10;    &#10;    // Calcular total (10 líneas de código)&#10;    double total = 0;&#10;    for (Movement m : movements) {&#10;        if (m.getMovementType().equals(&quot;ENTRADA&quot;)) {&#10;            total += m.getQuantity();&#10;        }&#10;    }&#10;    &#10;    // ... más lógica repetitiva&#10;}&#10;```&#10;&#10;**Después (Fase 2.5 - código organizado con Manager):**&#10;```java&#10;// Main.java - SOLO coordina&#10;public static void main(String[] args) {&#10;    MovementManager manager = new MovementManager();&#10;    &#10;    // Agregar movimiento (1 línea)&#10;    manager.addMovement(&quot;ENTRADA&quot;, &quot;Diesel&quot;, 100, 3.45);&#10;    &#10;    // Buscar por ID (1 línea)&#10;    Movement found = manager.findById(idBuscado);&#10;    &#10;    // Calcular total (1 línea)&#10;    double total = manager.calculateTotalEntered();&#10;}&#10;&#10;// MovementManager.java - ESPECIALISTA en gestionar movimientos&#10;public class MovementManager {&#10;    private List&lt;Movement&gt; movements;&#10;    &#10;    public Movement findById(String id) {&#10;        for (Movement m : movements) {&#10;            if (m.getId().equals(id)) return m;&#10;        }&#10;        return null;&#10;    }&#10;    &#10;    public double calculateTotalEntered() {&#10;        double total = 0;&#10;        for (Movement m : movements) {&#10;            if (m.getMovementType().equals(&quot;ENTRADA&quot;)) {&#10;                total += m.getQuantity();&#10;            }&#10;        }&#10;        return total;&#10;    }&#10;    // ... más métodos especializados&#10;}&#10;```&#10;&#10;###  ¿Qué ganas con MovementManager?&#10;&#10;**Ventajas arquitectónicas:**&#10;- ✅ **Separación de responsabilidades:** Main coordina, Manager gestiona&#10;- ✅ **Código reutilizable:** Puedes usar MovementManager en otros lugares&#10;- ✅ **Fácil de testear:** Puedes probar MovementManager independientemente&#10;- ✅ **Mantenible:** Si cambias cómo buscas, solo modificas findById()&#10;- ✅ **Escalable:** Agregar nuevas funcionalidades no afecta a Main&#10;- ✅ **Profesional:** Así se estructura código en proyectos reales&#10;&#10;**Comparación directa:**&#10;&#10;| Aspecto | Fase 2.6 (código en Main) | Fase 2.5 (MovementManager) |&#10;|---------|---------------------------|----------------------------|&#10;| Líneas en Main | 200-500 | 20-50 |&#10;| Reutilizable | ❌ No | ✅ Sí |&#10;| Testeable | ❌ Difícil | ✅ Fácil |&#10;| Mantenible | ❌ Difícil | ✅ Fácil |&#10;| Escalable | ❌ No | ✅ Sí |&#10;| Profesional | ⚠️ Nivel aprendizaje | ✅ Nivel producción |&#10;&#10;###  ¿Qué aprenderás en Fase 2.5?&#10;&#10;**Conceptos nuevos:**&#10;1. **Patrón Manager:** Clase dedicada a gestionar colecciones&#10;2. **List vs ArrayList:** Programar contra interfaces (buena práctica)&#10;3. **Javadoc:** Documentar métodos profesionalmente&#10;4. **Encapsulación avanzada:** ArrayList privado + métodos públicos&#10;&#10;**Conceptos que REUTILIZARÁS de Fase 2:**&#10;- ✅ ArrayList y sus métodos (.add, .size, .get)&#10;- ✅ For-each loop para recorrer colecciones&#10;- ✅ Comparación con .equals() para Strings&#10;- ✅ Patrón acumulador para calcular totales&#10;- ✅ Búsqueda lineal con break&#10;- ✅ Filtrado creando nueva lista&#10;&#10;###  Roadmap de la Fase 2.5:&#10;&#10;```&#10;Checkpoint 2.5.1: Crear paquete managers/&#10;    ↓&#10;Checkpoint 2.5.2: Crear clase MovementManager&#10;    ├── Atributo: List&lt;Movement&gt; movements&#10;    ├── Constructor: inicializar ArrayList&#10;    ├── addMovement(): crear y agregar&#10;    ├── getAllMovements(): retornar lista&#10;    ├── findById(): buscar por ID&#10;    ├── getMovementsByType(): filtrar&#10;    ├── getTotalMovements(): contar&#10;    └── calculate...: sumas y diferencias&#10;    ↓&#10;Checkpoint 2.5.3: Compilar y verificar&#10;    ↓&#10;Checkpoint 2.5.4: Probar TODOS los métodos en Main&#10;    ↓&#10;Resultado: MovementManager funcional y profesional&#10;```&#10;&#10;###  Pregunta de reflexión antes de empezar:&#10;&#10;**¿Puedes explicar con tus palabras por qué es mejor tener una clase MovementManager en lugar de gestionar el ArrayList directamente en Main.java?**&#10;&#10;Pista: Piensa en términos de:&#10;- Responsabilidades (¿quién hace qué?)&#10;- Reutilización (¿puedo usar el código en otro lugar?)&#10;- Mantenimiento (¿qué pasa si necesito cambiar cómo busco?)&#10;&#10;---&#10;```&#10;&#10;---&#10;&#10;##  MEJORA #2: Explicar List vs ArrayList (PRIORIDAD ALTA)&#10;&#10;### **Ubicación:** En &quot;PASO 2: Declarar el atributo privado&quot;, después de &quot;TÚ debes agregar el atributo&quot;&#10;&#10;### **Contenido a insertar:**&#10;&#10;```markdown&#10;---&#10;&#10;###  IMPORTANTE: ¿Por qué `List&lt;Movement&gt;` y no `ArrayList&lt;Movement&gt;`?&#10;&#10;**Comparación con Checkpoint 2.6:**&#10;&#10;En Fase 2 - Checkpoint 2.6 escribiste:&#10;```java&#10;ArrayList&lt;Movement&gt; movements = new ArrayList&lt;&gt;();&#10;```&#10;&#10;Ahora en Fase 2.5 escribes:&#10;```java&#10;private List&lt;Movement&gt; movements;  // ← List (interfaz)&#10;this.movements = new ArrayList&lt;&gt;();  // ← ArrayList (implementación)&#10;```&#10;&#10;**¿Notas la diferencia? Declaras como `List`, pero instancias como `ArrayList`.**&#10;&#10;###  ¿Qué significa esto?&#10;&#10;```&#10;List&lt;Movement&gt;&#10;├── Es una INTERFAZ (el &quot;qué&quot;)&#10;├── Define los métodos: add(), get(), size(), remove()&#10;└── No se puede instanciar directamente: new List&lt;&gt;() ❌&#10;&#10;ArrayList&lt;Movement&gt;&#10;├── Es una IMPLEMENTACIÓN (el &quot;cómo&quot;)&#10;├── Implementa la interfaz List&#10;├── Usa un arreglo dinámico internamente&#10;└── Se puede instanciar: new ArrayList&lt;&gt;() ✅&#10;```&#10;&#10;###  Analogía del Mundo Real:&#10;&#10;```&#10;List = &quot;Necesito un vehículo&quot; (concepto abstracto)&#10;ArrayList = &quot;Específicamente un automóvil Toyota&quot; (implementación concreta)&#10;&#10;Cuando declaras:&#10;List&lt;Movement&gt; movements;  // Dices: &quot;Necesito algo que actúe como lista&quot;&#10;&#10;Cuando instancias:&#10;new ArrayList&lt;&gt;();  // Dices: &quot;Usa un ArrayList como implementación&quot;&#10;```&#10;&#10;###  ¿Por qué hacemos esto? (Buena práctica profesional)&#10;&#10;**✅ VENTAJAS:**&#10;&#10;1. **Flexibilidad futura:**&#10;   ```java&#10;   // Si decides cambiar la implementación:&#10;   // ANTES (solo cambias 1 línea):&#10;   this.movements = new LinkedList&lt;&gt;();  // Cambio fácil&#10;   &#10;   // Si hubieras declarado ArrayList&lt;Movement&gt;, tendrías que cambiar:&#10;   // - El atributo&#10;   // - El constructor&#10;   // - Todos los métodos que retornan ArrayList&#10;   ```&#10;&#10;2. **Programar contra interfaces (Principio de Inversión de Dependencias):**&#10;   ```java&#10;   // Tu código depende de List (abstracción)&#10;   // NO depende de ArrayList (implementación concreta)&#10;   // Esto hace el código más robusto y profesional&#10;   ```&#10;&#10;3. **Compatibilidad:**&#10;   ```java&#10;   // Este método puede recibir cualquier tipo de List:&#10;   public void procesarMovimientos(List&lt;Movement&gt; lista) {&#10;       // Funciona con ArrayList, LinkedList, Vector, etc.&#10;   }&#10;   ```&#10;&#10;###  Comparación Visual:&#10;&#10;```&#10;OPCIÓN 1 (Lo que aprendiste en 2.6 - correcto para aprender):&#10;┌─────────────────────────────────────┐&#10;│ ArrayList&lt;Movement&gt; movements       │ ← Declaración específica&#10;│         = new ArrayList&lt;&gt;();        │ ← Instanciación&#10;└─────────────────────────────────────┘&#10;&#10;OPCIÓN 2 (Lo que usas en 2.5 - práctica profesional):&#10;┌─────────────────────────────────────┐&#10;│ List&lt;Movement&gt; movements            │ ← Declaración genérica (interfaz)&#10;│         = new ArrayList&lt;&gt;();        │ ← Instanciación específica&#10;└─────────────────────────────────────┘&#10;```&#10;&#10;###  Regla Práctica (Memorízala):&#10;&#10;```&#10;╔════════════════════════════════════════════════════════╗&#10;║  DECLARACIÓN (tipo del atributo/parámetro/retorno):   ║&#10;║  → Usa la INTERFAZ (List&lt;Movement&gt;)                   ║&#10;║                                                        ║&#10;║  INSTANCIACIÓN (new ...):                             ║&#10;║  → Usa la IMPLEMENTACIÓN (new ArrayList&lt;&gt;())          ║&#10;╚════════════════════════════════════════════════════════╝&#10;```&#10;&#10;**Ejemplos:**&#10;```java&#10;// ✅ CORRECTO (profesional):&#10;List&lt;Movement&gt; lista = new ArrayList&lt;&gt;();&#10;List&lt;String&gt; nombres = new LinkedList&lt;&gt;();&#10;Map&lt;String, Integer&gt; edades = new HashMap&lt;&gt;();&#10;&#10;// ⚠️ FUNCIONA PERO NO ES IDEAL:&#10;ArrayList&lt;Movement&gt; lista = new ArrayList&lt;&gt;();&#10;LinkedList&lt;String&gt; nombres = new LinkedList&lt;&gt;();&#10;HashMap&lt;String, Integer&gt; edades = new HashMap&lt;&gt;();&#10;```&#10;&#10;###  ¿Por qué no puedes hacer `new List&lt;&gt;()`?&#10;&#10;```java&#10;List&lt;Movement&gt; movements = new List&lt;&gt;();  // ❌ ERROR DE COMPILACIÓN&#10;```&#10;&#10;**Razón:**&#10;- `List` es una **interfaz** (contrato abstracto)&#10;- Las interfaces NO tienen implementación concreta&#10;- No se pueden instanciar directamente&#10;- Necesitas una **clase que implemente** la interfaz: ArrayList, LinkedList, Vector, etc.&#10;&#10;**Analogía:**&#10;- No puedes &quot;construir un vehículo genérico&quot;&#10;- Necesitas construir un tipo específico: automóvil, camión, motocicleta&#10;- Pero puedes DECLARAR que &quot;necesitas un vehículo&quot; sin especificar cuál&#10;&#10;###  Otras implementaciones de `List`:&#10;&#10;```java&#10;// Todas estas son VÁLIDAS:&#10;List&lt;Movement&gt; movements = new ArrayList&lt;&gt;();    // ← Más usada (rápida para acceder por índice)&#10;List&lt;Movement&gt; movements = new LinkedList&lt;&gt;();   // ← Rápida para insertar/eliminar&#10;List&lt;Movement&gt; movements = new Vector&lt;&gt;();       // ← Thread-safe (sincronizada)&#10;List&lt;Movement&gt; movements = new Stack&lt;&gt;();        // ← LIFO (Last In First Out)&#10;```&#10;&#10;**Por ahora usa ArrayList** - es la más común para casos generales.&#10;&#10;### ❓ Preguntas de Autoevaluación:&#10;&#10;Antes de continuar, asegúrate de poder responder:&#10;&#10;1. ¿Cuál es la diferencia entre `List` y `ArrayList`?&#10;   &lt;details&gt;&#10;   &lt;summary&gt;Ver respuesta&lt;/summary&gt;&#10;   List es la interfaz (contrato), ArrayList es una implementación concreta.&#10;   &lt;/details&gt;&#10;&#10;2. ¿Por qué declaramos como `List&lt;Movement&gt;` pero instanciamos con `new ArrayList&lt;&gt;()`?&#10;   &lt;details&gt;&#10;   &lt;summary&gt;Ver respuesta&lt;/summary&gt;&#10;   Para programar contra la interfaz (flexibilidad) pero usar una implementación específica.&#10;   &lt;/details&gt;&#10;&#10;3. ¿Qué error obtienes si haces `new List&lt;&gt;()`?&#10;   &lt;details&gt;&#10;   &lt;summary&gt;Ver respuesta&lt;/summary&gt;&#10;   Error de compilación: las interfaces no se pueden instanciar.&#10;   &lt;/details&gt;&#10;&#10;4. ¿Cuándo cambiarías ArrayList por LinkedList?&#10;   &lt;details&gt;&#10;   &lt;summary&gt;Ver respuesta&lt;/summary&gt;&#10;   Cuando necesites insertar/eliminar elementos frecuentemente en el medio de la lista.&#10;   &lt;/details&gt;&#10;&#10;###  Para Profundizar (Opcional - Fase 8):&#10;&#10;En Fase 8 (Temas Avanzados) aprenderás:&#10;- Diferencias de rendimiento entre ArrayList y LinkedList&#10;- Cuándo usar cada implementación&#10;- El patrón Strategy aplicado a colecciones&#10;&#10;Por ahora, **memoriza la regla práctica** y continúa con el siguiente paso.&#10;&#10;---&#10;```&#10;&#10;---&#10;&#10;##  MEJORA #3: Introducir Javadoc (PRIORIDAD MEDIA)&#10;&#10;### **Ubicación:** En &quot;PASO 4: Método addMovement()&quot;, antes de &quot;TÚ debes escribir&quot;&#10;&#10;### **Contenido a insertar:**&#10;&#10;```markdown&#10;---&#10;&#10;###  NUEVO CONCEPTO: Javadoc (Documentación de Métodos)&#10;&#10;Antes de implementar `addMovement()`, aprenderás a documentarlo profesionalmente con **Javadoc**.&#10;&#10;#### ¿Qué es Javadoc?&#10;&#10;**Javadoc** es un tipo especial de comentario que:&#10;-  **Documenta** clases, métodos y atributos&#10;-  **Genera documentación automática** (HTML)&#10;-  **Aparece en el IDE** cuando usas el método (hover o Ctrl+Q)&#10;&#10;#### Tipos de comentarios en Java:&#10;&#10;```java&#10;// 1. Comentario de una línea&#10;// Útil para notas breves&#10;&#10;/* 2. Comentario de bloque&#10;   Útil para comentarios&#10;   de múltiples líneas */&#10;&#10;/** 3. Comentario Javadoc&#10; *  Genera DOCUMENTACIÓN OFICIAL&#10; *  Aparece en el IDE cuando usas el código&#10; */&#10;```&#10;&#10;#### Estructura de Javadoc:&#10;&#10;```java&#10;/**&#10; * Descripción breve de qué hace el método (OBLIGATORIO).&#10; * &#10; * Puedes agregar una descripción más detallada aquí&#10; * explicando comportamientos específicos, restricciones, etc.&#10; * &#10; * @param nombreParametro1 Descripción de qué es este parámetro&#10; * @param nombreParametro2 Descripción de qué es este parámetro&#10; * @return Descripción de qué retorna el método&#10; * @throws TipoExcepcion Cuándo se lanza esta excepción (Fase 7)&#10; */&#10;public TipoRetorno nombreMetodo(Tipo param1, Tipo param2) {&#10;    // Implementación&#10;}&#10;```&#10;&#10;#### Ejemplo con Movement:&#10;&#10;```java&#10;/**&#10; * Crea un nuevo movimiento de combustible y lo agrega a la lista.&#10; * &#10; * Este método instancia un objeto Movement con los parámetros proporcionados,&#10; * genera automáticamente un ID único, y lo almacena en la colección interna.&#10; * &#10; * @param movementType Tipo de movimiento (&quot;ENTRADA&quot; o &quot;SALIDA&quot;)&#10; * @param fuelType Tipo de combustible (ej: &quot;Diesel&quot;, &quot;Gasolina 93&quot;)&#10; * @param quantity Cantidad en litros (debe ser mayor a 0)&#10; * @param unitPrice Precio por litro en pesos (debe ser mayor a 0)&#10; * @return El objeto Movement creado (con ID generado)&#10; */&#10;public Movement addMovement(String movementType, String fuelType, &#10;                           double quantity, double unitPrice) {&#10;    Movement newMovement = new Movement(movementType, fuelType, quantity, unitPrice);&#10;    movements.add(newMovement);&#10;    return newMovement;&#10;}&#10;```&#10;&#10;#### ¿Cómo se ve en el IDE?&#10;&#10;Cuando alguien usa tu método:&#10;```java&#10;manager.addMovement(  // ← Al escribir esto, aparece un tooltip con la documentación&#10;```&#10;&#10;El IDE muestra:&#10;```&#10;addMovement(String movementType, String fuelType, double quantity, double unitPrice)&#10;&#10;Crea un nuevo movimiento de combustible y lo agrega a la lista.&#10;&#10;Parameters:&#10;  movementType - Tipo de movimiento (&quot;ENTRADA&quot; o &quot;SALIDA&quot;)&#10;  fuelType - Tipo de combustible (ej: &quot;Diesel&quot;, &quot;Gasolina 93&quot;)&#10;  quantity - Cantidad en litros (debe ser mayor a 0)&#10;  unitPrice - Precio por litro en pesos (debe ser mayor a 0)&#10;&#10;Returns:&#10;  El objeto Movement creado (con ID generado)&#10;```&#10;&#10;#### Tags de Javadoc más comunes:&#10;&#10;| Tag | Uso | Ejemplo |&#10;|-----|-----|---------|&#10;| `@param` | Documentar parámetros | `@param id Identificador único` |&#10;| `@return` | Documentar retorno | `@return El movimiento encontrado o null` |&#10;| `@throws` | Documentar excepciones | `@throws IllegalArgumentException Si quantity &lt;= 0` |&#10;| `@see` | Referenciar otro método | `@see #findById(String)` |&#10;| `@since` | Versión en que se agregó | `@since 1.0` |&#10;| `@deprecated` | Marcar como obsoleto | `@deprecated Usar addMovement() en su lugar` |&#10;&#10;#### Buenas prácticas de Javadoc:&#10;&#10;✅ **HAZ ESTO:**&#10;```java&#10;/**&#10; * Busca un movimiento por su identificador único.&#10; * &#10; * @param id El ID del movimiento a buscar&#10; * @return El movimiento encontrado, o null si no existe&#10; */&#10;public Movement findById(String id) { ... }&#10;```&#10;&#10;❌ **NO HAGAS ESTO:**&#10;```java&#10;/**&#10; * Busca.&#10; * &#10; * @param id id&#10; * @return movement&#10; */&#10;public Movement findById(String id) { ... }&#10;// ❌ Demasiado vago, no agrega valor&#10;```&#10;&#10;#### ¿Cuándo usar Javadoc?&#10;&#10;**SÍ documenta con Javadoc:**&#10;- ✅ Métodos públicos (otros las usarán)&#10;- ✅ Clases públicas (especialmente abstracciones)&#10;- ✅ Constantes públicas importantes&#10;&#10;**NO necesitas Javadoc para:**&#10;- ❌ Métodos privados muy simples&#10;- ❌ Getters/Setters triviales (el nombre ya lo explica)&#10;- ❌ Métodos obvios (`toString()`, constructores simples)&#10;&#10;**Ejemplo de cuándo SÍ y cuándo NO:**&#10;&#10;```java&#10;/**&#10; * Calcula el stock actual de combustible.&#10; * &#10; * El stock se calcula como la diferencia entre todas las entradas&#10; * y todas las salidas registradas.&#10; * &#10; * @return Stock actual en litros&#10; */&#10;public double getCurrentStock() {  // ✅ SÍ (lógica no trivial)&#10;    return calculateTotalEntered() - calculateTotalExited();&#10;}&#10;&#10;// ❌ NO necesitas Javadoc aquí (es obvio):&#10;public int getTotalMovements() {&#10;    return movements.size();&#10;}&#10;```&#10;&#10;#### Ejercicio rápido:&#10;&#10;**TÚ escribes el Javadoc para este método:**&#10;&#10;```java&#10;// Escribe el Javadoc aquí&#10;public List&lt;Movement&gt; getMovementsByType(String type) {&#10;    List&lt;Movement&gt; result = new ArrayList&lt;&gt;();&#10;    for (Movement m : movements) {&#10;        if (m.getMovementType().equals(type)) {&#10;            result.add(m);&#10;        }&#10;    }&#10;    return result;&#10;}&#10;```&#10;&#10;&lt;details&gt;&#10;&lt;summary&gt;Ver solución sugerida&lt;/summary&gt;&#10;&#10;```java&#10;/**&#10; * Filtra los movimientos por tipo (ENTRADA o SALIDA).&#10; * &#10; * Recorre todos los movimientos almacenados y retorna solo aquellos&#10; * que coincidan con el tipo especificado.&#10; * &#10; * @param type El tipo de movimiento a filtrar (&quot;ENTRADA&quot; o &quot;SALIDA&quot;)&#10; * @return Una nueva lista con los movimientos filtrados (puede estar vacía)&#10; */&#10;public List&lt;Movement&gt; getMovementsByType(String type) {&#10;    List&lt;Movement&gt; result = new ArrayList&lt;&gt;();&#10;    for (Movement m : movements) {&#10;        if (m.getMovementType().equals(type)) {&#10;            result.add(m);&#10;        }&#10;    }&#10;    return result;&#10;}&#10;```&#10;&#10;&lt;/details&gt;&#10;&#10;---&#10;&#10;### ✅ Ahora sí: Implementar `addMovement()`&#10;&#10;Con el conocimiento de Javadoc, **TÚ debes escribir:**&#10;&#10;[...continúa con el contenido original del PASO 4...]&#10;```&#10;&#10;---&#10;&#10;## ✅ IMPLEMENTACIÓN DE MEJORAS&#10;&#10;### Pasos para aplicar las mejoras:&#10;&#10;1. **Crear backup de FASE_02.5_MOVEMENTMANAGER.md**&#10;2. **Insertar Mejora #1** después de &quot;Antes de empezar&quot;&#10;3. **Insertar Mejora #2** en PASO 2 (Declarar atributo)&#10;4. **Insertar Mejora #3** en PASO 4 (addMovement)&#10;5. **Validar** que la numeración de pasos siga siendo coherente&#10;6. **Revisar** que las referencias cruzadas funcionen&#10;&#10;### Estimación de tiempo:&#10;&#10;- Aplicar mejoras: 30 minutos&#10;- Revisar coherencia: 15 minutos&#10;- Validar con el estudiante: 1 hora&#10;- **Total: ~2 horas**&#10;&#10;---&#10;&#10;##  IMPACTO ESPERADO&#10;&#10;### Antes de las mejoras:&#10;- ⚠️ Posible confusión sobre List vs ArrayList&#10;- ⚠️ Falta de contexto sobre el &quot;por qué&quot; del Manager&#10;- ⚠️ Javadoc introducido abruptamente&#10;&#10;### Después de las mejoras:&#10;- ✅ Conexión clara con Checkpoint 2.6&#10;- ✅ Entendimiento de List como interfaz vs ArrayList como implementación&#10;- ✅ Comprensión de Javadoc como herramienta profesional&#10;- ✅ Motivación clara para usar el patrón Manager&#10;&#10;### Beneficio pedagógico:&#10;-  Incrementa comprensión: 8/10 → 10/10&#10;-  Reduce confusión: -60%&#10;-  Aumenta motivación: &quot;Ahora entiendo por qué lo hacemos así&quot;&#10;&#10;---&#10;&#10;##  VALIDACIÓN POST-MEJORA&#10;&#10;### Preguntas de autoevaluación para el estudiante:&#10;&#10;Después de implementar las mejoras, el estudiante debe poder responder:&#10;&#10;1. **¿Por qué MovementManager es mejor que gestionar ArrayList en Main?**&#10;   - Esperado: Separación de responsabilidades, reutilización, mantenimiento&#10;&#10;2. **¿Cuál es la diferencia entre List y ArrayList?**&#10;   - Esperado: List es interfaz (contrato), ArrayList es implementación&#10;&#10;3. **¿Para qué sirve Javadoc?**&#10;   - Esperado: Documentar código, aparece en IDE, genera documentación automática&#10;&#10;4. **¿Qué aprendizaje de Checkpoint 2.6 estamos profesionalizando?**&#10;   - Esperado: Gestión de ArrayList&lt;Movement&gt; en Main&#10;&#10;Si el estudiante responde correctamente estas 4 preguntas:&#10;✅ **Las mejoras fueron efectivas**&#10;&#10;---&#10;&#10;**Fin del documento de mejoras sugeridas**&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>