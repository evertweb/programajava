# 🛠️ FASE 4: OPERACIONES CRUD (Semanas 6-7)

> Objetivo general: dominar operaciones completas de base de datos (CREATE, READ, UPDATE, DELETE) usando PreparedStatement con validaciones y buenas prácticas de seguridad.

---

## 🧠 Antes de empezar

- 📚 **Fundamentos SQL CRUD:** Repasa en SQL Server Management Studio:
  - INSERT INTO con múltiples columnas y valores
  - SELECT con WHERE y diferentes tipos de filtros
  - UPDATE con WHERE (¡NUNCA sin WHERE!)
  - DELETE con WHERE y validación de integridad referencial
- 📝 **Documenta tus pruebas SQL:** Ejecuta manualmente cada operación en SQL Server y anota los resultados en `JAVA_LEARNING_LOG.md`
- 🔐 **Seguridad:** Investiga qué es SQL Injection y por qué PreparedStatement es obligatorio
- 🔁 **Git loop:** Al completar cada checkpoint crea un commit (`git commit -m "fase4 checkpoint 4.1"`)
- 🎯 **CRUD COMPLETO:** Crearás services para cada entidad siguiendo un patrón consistente
- ✍️ **APRENDIZAJE ACTIVO:** Recibirás DIRECTIVAS y especificaciones. TÚ escribirás el código y entenderás cada operación.

---

## 📦 ESTRUCTURA AL TERMINAR FASE 3

Antes de empezar Fase 4, debes tener esta estructura:

```
com.forestech/
├── Main.java
├── AppConfig.java
├── MenuHelper.java
├── DataDisplay.java
├── InputHelper.java
├── config/
│   └── DatabaseConnection.java
├── models/
│   ├── Movement.java
│   ├── Vehicle.java
│   ├── Supplier.java
│   └── Product.java
└── services/
    └── ProductService.java (solo SELECT)
```

**Verifica que ProductService ya tenga:**
- `getAllProducts()` - retorna List<Product>
- `getProductById(String id)` - retorna Product con PreparedStatement
- `getProductsByType(String type)` - retorna List<Product> filtrada

---

## 🎯 ESTRUCTURA AL TERMINAR FASE 4

Al finalizar esta fase tendrás:

```
com.forestech/
├── Main.java (pruebas CRUD completas)
├── AppConfig.java
├── MenuHelper.java
├── DataDisplay.java
├── InputHelper.java
├── config/
│   └── DatabaseConnection.java
├── models/
│   ├── Movement.java
│   ├── Vehicle.java
│   ├── Supplier.java
│   └── Product.java
├── managers/
│   └── MovementManager.java (DEPRECATED - ahora se usa MovementService)
└── services/
    ├── MovementService.java (NUEVO - CRUD completo)
    ├── VehicleService.java (NUEVO - CRUD completo)
    ├── SupplierService.java (NUEVO - CRUD completo)
    └── ProductService.java (EXTENDIDO - ahora con INSERT, UPDATE, DELETE)
```

**Filosofía de la fase:**
- **Services completos:** Cada service tendrá las 4 operaciones CRUD
- **Validaciones previas:** Verificar existencia antes de UPDATE/DELETE
- **Integridad referencial:** No permitir DELETE si hay relaciones
- **PreparedStatement siempre:** Para TODAS las operaciones (no solo SELECT)
- **Manejo de errores:** try-catch apropiado en cada método
- **Retornos consistentes:** boolean para operaciones de escritura, objetos/listas para lectura

---

## ✅ Checkpoint 4.1: Insertar movimientos (INSERT)

**Concepto clave:** PreparedStatement con placeholders (?) previene SQL Injection y permite insertar datos de forma segura desde objetos Java a la base de datos.

**📍 DÓNDE:** 
- **Crear archivo:** `MovementService.java` en `forestech-cli-java/src/main/java/com/forestech/services/`
- **Modificar:** `Main.java` para PROBAR la inserción

**🎯 PARA QUÉ:** 
Hasta Fase 3 solo LEES datos (SELECT). Ahora necesitas CREAR datos:
- ✅ **Persistir movimientos** creados en Java hacia SQL Server
- ✅ **Registrar operaciones** del usuario en la aplicación
- ✅ **Evitar perder datos** cuando cierras la aplicación
- ✅ **Completar el ciclo de datos:** crear objetos Java → guardar en BD → recuperar después

**Diferencia con Fase 3:**
```
FASE 3:
BD (datos ya existen) → SELECT → Java (lee y muestra)

FASE 4:
Java (crea objeto Movement) → INSERT → BD (guarda permanentemente)
```

**🔗 CONEXIÓN FUTURA:**
- **Fase 5:** Agregarás validaciones de negocio antes de insertar (verificar inventario disponible)
- **Fase 6:** El menú interactivo llamará a createMovement() cuando el usuario registre operaciones
- **Fase 7:** Manejarás errores específicos (duplicados, violaciones de FK)
- **Fase 9:** Los movimientos insertados aparecerán en reportes y análisis

**🎓 Analogía:**
- **SELECT (Fase 3):** Leer un libro de la biblioteca
- **INSERT (Fase 4):** Escribir un nuevo libro y agregarlo a la biblioteca

**Prompts sugeridos:**
```text
"¿Cuál es la diferencia entre executeQuery() y executeUpdate()?"
"Explícame paso a paso cómo PreparedStatement previene SQL Injection."
"¿Por qué executeUpdate() retorna un int? ¿Qué significa ese número?"
"¿En qué orden se asignan los valores a los placeholders (?)?"
"¿Qué pasa si olvido asignar un valor a un placeholder?"
```

**Tareas paso a paso:**

1. **Crear la clase MovementService:**
   
   - Clic derecho en paquete `services` → New → Java Class → "MovementService"
   - Declarar como clase pública
   - Constructor privado (es una utility class con métodos estáticos por ahora)
   
   **Pregunta guía:** ¿Por qué usamos métodos estáticos en vez de crear instancias?

2. **Imports necesarios (boilerplate permitido):**
   
   ```java
   import com.forestech.config.DatabaseConnection;
   import com.forestech.models.Movement;
   import java.sql.Connection;
   import java.sql.PreparedStatement;
   import java.sql.SQLException;
   ```

3. **Crear método `createMovement(Movement movement)`:**
   
   **Especificaciones:**
   - Modificador: `public static`
   - Tipo de retorno: `boolean` (true si se insertó, false si falló)
   - Parámetros: `Movement movement` (el objeto a guardar)
   
   **Pregunta guía:** ¿Por qué retornar boolean en vez de void?

4. **Definir la query SQL INSERT:**
   
   **Especificaciones (TÚ debes escribir la query):**
   - INSERT INTO la tabla `combustibles_movements`
   - Columnas a insertar: id, movementType, fuelType, quantity, unitPrice, movementDate
   - Usa placeholders (?) para TODOS los valores
   - NO uses concatenación de strings
   
   **Formato:**
   ```java
   String sql = "INSERT INTO tabla (col1, col2, col3) VALUES (?, ?, ?)";
   ```
   
   **Pregunta guía:** ¿Por qué usar placeholders en vez de concatenar valores directamente?
   
   **⚠️ PELIGRO - SQL Injection:**
   ```java
   // ❌ NUNCA HACER ESTO:
   String sql = "INSERT INTO movements VALUES ('" + movement.getId() + "')";
   // ☠️ Vulnerable a SQL Injection
   
   // ✅ SIEMPRE HACER ESTO:
   String sql = "INSERT INTO movements VALUES (?)";
   pstmt.setString(1, movement.getId());
   // ✅ Seguro contra SQL Injection
   ```

5. **Implementar la lógica de inserción:**
   
   **Estructura del método (TÚ completas la implementación):**
   
   a) Usar try-with-resources para Connection y PreparedStatement:
      ```java
      try (Connection conn = DatabaseConnection.getConnection();
           PreparedStatement pstmt = conn.prepareStatement(sql)) {
          
          // Configurar parámetros aquí
          
      } catch (SQLException e) {
          // Manejo de error aquí
      }
      ```
   
   b) Configurar los parámetros del PreparedStatement:
      - Usa los getters del objeto Movement para obtener los valores
      - Asigna cada valor al placeholder correspondiente usando:
        - `pstmt.setString(indice, valor)` para Strings
        - `pstmt.setDouble(indice, valor)` para doubles
      - El índice empieza en 1 (no en 0)
      
   **Ejemplo del primer parámetro:**
   ```java
   pstmt.setString(1, movement.getId());  // Primer ? (id)
   ```
   
   **TÚ debes configurar los demás:**
   - Segundo ? (movementType)
   - Tercero ? (fuelType)
   - Cuarto ? (quantity)
   - Quinto ? (unitPrice)
   - Sexto ? (movementDate)
   
   **Pregunta guía:** ¿Qué pasa si el orden de los setString no coincide con el orden de los ? en la query?
   
   c) Ejecutar la inserción:
      ```java
      int rowsAffected = pstmt.executeUpdate();
      ```
      
   **Pregunta guía:** ¿Por qué usamos executeUpdate() y no executeQuery()?
   
   d) Verificar el resultado:
      - Si `rowsAffected == 1`: inserción exitosa → retornar true
      - Si `rowsAffected == 0`: no se insertó nada → imprimir mensaje y retornar false
      - Imprime mensaje de confirmación con los datos insertados
   
   e) En el bloque catch:
      - Imprimir mensaje de error descriptivo
      - Imprimir el mensaje de la excepción: `e.getMessage()`
      - Retornar false

6. **Probar en Main.java:**
   
   **Crear prueba de inserción:**
   
   ```java
   System.out.println("\n=== PRUEBA DE INSERCIÓN DE MOVEMENT ===");
   
   // TÚ debes escribir:
   // 1. Crear un objeto Movement con datos de prueba
   //    - Usa el constructor que ya existe en Movement.java
   //    - Ejemplo: tipo "ENTRADA", combustible "Diesel", cantidad 1000.0
   // 2. Llamar a MovementService.createMovement(movement)
   // 3. Verificar el resultado (true/false)
   // 4. Imprimir mensaje según el resultado
   ```
   
   **Verificación manual en SQL Server:**
   - Abre SQL Server Management Studio
   - Ejecuta: `SELECT * FROM combustibles_movements ORDER BY movementDate DESC`
   - Verifica que tu movimiento aparece con los datos correctos

7. **Depuración obligatoria:**
   
   **Coloca breakpoints en:**
   - Línea donde creas el PreparedStatement
   - Línea donde ejecutas executeUpdate()
   - Línea dentro del catch (para ver errores)
   
   **En el debugger:**
   - Inspecciona el objeto `movement` antes de insertar
   - Evalúa `pstmt.toString()` para ver la query con valores
   - Verifica el valor de `rowsAffected` después de executeUpdate()
   - Si falla, revisa el mensaje de la SQLException

**✅ Resultado esperado:** 
- Método `createMovement()` implementado en MovementService.java
- Main.java crea un Movement y lo guarda exitosamente
- Ver mensaje de confirmación en consola con los datos insertados
- Verificar en SQL Server que el registro existe con los datos correctos
- Si hay error, ver mensaje descriptivo del problema
- Estructura actualizada:
  ```
  com.forestech/
  ├── Main.java (con prueba de inserción)
  ├── config/
  │   └── DatabaseConnection.java
  ├── models/
  │   └── Movement.java
  └── services/
      ├── ProductService.java
      └── MovementService.java (NUEVO)
  ```

**💡 Concepto clave - executeUpdate() vs executeQuery():**

```
executeQuery():
- Usado para SELECT (consultas que RETORNAN datos)
- Retorna ResultSet con los datos
- NO modifica la base de datos

executeUpdate():
- Usado para INSERT, UPDATE, DELETE (operaciones que MODIFICAN datos)
- Retorna int (número de filas afectadas)
- SÍ modifica la base de datos
```

**💡 Concepto clave - Orden de parámetros:**

```
SQL: "INSERT INTO movements (id, type, fuel) VALUES (?, ?, ?)"
                                                      ↑   ↑   ↑
                                                      1   2   3

Java:
pstmt.setString(1, movement.getId());      // → Primer ?
pstmt.setString(2, movement.getType());    // → Segundo ?
pstmt.setString(3, movement.getFuel());    // → Tercer ?

❌ SI CAMBIAS EL ORDEN, los datos se guardan en las columnas incorrectas
```

**💡 Concepto clave - try-with-resources:**

```
¿Por qué usar try-with-resources?

SIN try-with-resources (antiguo):
Connection conn = null;
PreparedStatement pstmt = null;
try {
    conn = DatabaseConnection.getConnection();
    pstmt = conn.prepareStatement(sql);
    // ...
} finally {
    if (pstmt != null) pstmt.close();  // Código repetitivo
    if (conn != null) conn.close();
}

CON try-with-resources (moderno):
try (Connection conn = DatabaseConnection.getConnection();
     PreparedStatement pstmt = conn.prepareStatement(sql)) {
    // ...
}  // ✅ Se cierran automáticamente en orden inverso

Ventajas:
- Más conciso y legible
- Cierre garantizado incluso si hay excepción
- Orden de cierre automático (último abierto, primero cerrado)
```

**⚠️ CUIDADOS:**

| Problema común | Causa | Solución |
|----------------|-------|----------|
| "Parameter index out of range" | Índice incorrecto o placeholders mal contados | Cuenta los ? en tu query y verifica índices 1, 2, 3... |
| "Column count doesn't match" | Diferente número de columnas vs valores | Verifica que cada columna en INSERT tenga su ? correspondiente |
| "Cannot insert NULL" | No asignaste valor a un placeholder | Verifica que llamaste setString/setDouble para TODOS los ? |
| rowsAffected = 0 | Query no falló pero no insertó | Verifica que la tabla existe y no hay constraints que bloqueen |
| SQLException sin mensaje claro | Error en la query SQL | Imprime la query completa y pruébala en SQL Server Management Studio |

**🔍 Depuración - Ver query compilada:**

En el debugger, evalúa:
```java
pstmt.toString()
```

Verás algo como:
```
PreparedStatement: INSERT INTO movements VALUES ('M001', 'ENTRADA', 'Diesel', 1000.0, ...)
```

Esto te muestra cómo se ve la query con los parámetros ya sustituidos. Puedes copiarla y probarla directamente en SQL Server.

**📊 Flujo completo de INSERT:**

```
1. Java crea objeto Movement
   Movement m = new Movement("ENTRADA", "Diesel", 1000.0, 3.5);

2. Pasa el objeto a MovementService
   boolean success = MovementService.createMovement(m);

3. MovementService extrae datos del objeto
   pstmt.setString(1, m.getId());
   pstmt.setString(2, m.getType());
   ... etc

4. executeUpdate() envía la query a SQL Server
   int rows = pstmt.executeUpdate();

5. SQL Server procesa el INSERT
   - Valida constraints (PK, FK, NOT NULL)
   - Inserta la fila si todo es válido

6. Retorna número de filas afectadas
   rows = 1 (éxito) o 0 (no se insertó)

7. MovementService retorna boolean
   return rows == 1;
```

**⏱️ Tiempo estimado:** 3-4 horas

---

## ✅ Checkpoint 4.2: Consultas filtradas (SELECT WHERE)

**Concepto clave:** Combinar PreparedStatement parametrizado con mapeo de ResultSet a objetos permite crear queries flexibles y seguras que retornan listas de datos filtrados.

**📍 DÓNDE:** 
- **Modificar:** `MovementService.java` (agregar nuevos métodos de lectura)
- **Main.java:** Para PROBAR los filtros

**🎯 PARA QUÉ:** 
En Checkpoint 4.1 insertaste datos. Ahora necesitas consultarlos de forma inteligente:
- ❌ **NO siempre quieres TODOS los movimientos** (pueden ser miles)
- ✅ **Filtrar por tipo:** Solo ENTRADAS o solo SALIDAS
- ✅ **Filtrar por combustible:** Solo movimientos de Diesel
- ✅ **Ordenar resultados:** Los más recientes primero
- ✅ **Búsquedas específicas:** Movimientos de una fecha concreta

**Diferencia con ProductService de Fase 3:**
```
ProductService (Fase 3):
- Leías productos que ya existían en la BD
- Solo SELECT, sin filtros complejos

MovementService (Fase 4):
- Lees movimientos que TÚ insertaste con Java
- SELECT con WHERE, ORDER BY, múltiples filtros
- Patrón completo de mapeo ResultSet → List<Objeto>
```

**🔗 CONEXIÓN FUTURA:**
- **Fase 5:** Calcularás inventario actual consultando movimientos con estos métodos
- **Fase 6:** El menú mostrará movimientos filtrados por tipo, fecha o combustible
- **Fase 7:** Validarás datos consultando movimientos existentes
- **Fase 9:** Generarás reportes consultando por rangos de fechas

**🎓 Analogía:**
- **getAllMovements():** "Tráeme todos los libros de la biblioteca"
- **getMovementsByType("ENTRADA"):** "Tráeme solo los libros de ciencia ficción"
- **getMovementsByFuelType("Diesel"):** "Tráeme solo los libros del autor Asimov"

**Prompts sugeridos:**
```text
"¿Cómo mapeo un ResultSet a un objeto Movement paso a paso?"
"¿Por qué es mejor retornar List<Movement> que imprimir directamente en el Service?"
"¿Qué hago si la consulta no retorna resultados? ¿Retorno null o lista vacía?"
"¿Cómo recorro un ResultSet y creo objetos al mismo tiempo?"
"¿Por qué usar ORDER BY en la query y no ordenar en Java?"
```

**Tareas paso a paso:**

1. **Crear método `getAllMovements()`:**
   
   **Especificaciones:**
   - Modificador: `public static`
   - Tipo de retorno: `List<Movement>`
   - Parámetros: ninguno
   - Retorna lista vacía si no hay movimientos
   
   **Pregunta guía:** ¿Por qué empezamos con getAllMovements() antes de los filtros?

2. **Implementación de getAllMovements():**
   
   **Estructura del método (TÚ la implementas):**
   
   a) Crear lista vacía al inicio:
      ```java
      List<Movement> movements = new ArrayList<>();
      ```
      
   b) Definir query SQL:
      - SELECT de todas las columnas necesarias
      - FROM combustibles_movements
      - ORDER BY movementDate DESC (más recientes primero)
      - SIN WHERE (queremos todos)
      
   c) Imports necesarios:
      ```java
      import java.util.List;
      import java.util.ArrayList;
      ```
   
   d) Usar try-with-resources:
      ```java
      try (Connection conn = DatabaseConnection.getConnection();
           PreparedStatement pstmt = conn.prepareStatement(sql);
           ResultSet rs = pstmt.executeQuery()) {
          
          // Código de mapeo aquí
          
      } catch (SQLException e) {
          // Manejo de error
      }
      ```
   
   **Pregunta guía:** ¿Por qué ResultSet también va en try-with-resources?
   
   e) Recorrer ResultSet y mapear a objetos:
      ```java
      while (rs.next()) {
          // TÚ debes implementar:
          // 1. Extraer cada columna del ResultSet
          // 2. Crear objeto Movement con esos datos
          // 3. Agregar el objeto a la lista
      }
      ```
   
   **Ejemplo de extracción de columnas:**
   ```java
   String id = rs.getString("id");
   String type = rs.getString("movementType");
   // ... continúa con las demás columnas
   ```
   
   **Pregunta guía:** ¿Los nombres en getString() deben coincidir con los nombres en la query SELECT?
   
   f) Retornar la lista (puede estar vacía):
      ```java
      return movements;
      ```
   
   g) En el catch:
      - Imprimir mensaje de error
      - Retornar lista vacía (NO null)
      
   **Pregunta guía:** ¿Por qué retornar lista vacía y no null cuando hay error?

3. **Crear método `getMovementsByType(String type)`:**
   
   **Especificaciones:**
   - Modificador: `public static`
   - Tipo de retorno: `List<Movement>`
   - Parámetros: `String type` ("ENTRADA" o "SALIDA")
   - Retorna lista filtrada o vacía
   
   **Implementación (TÚ la haces):**
   
   a) Query SQL con WHERE:
      ```java
      String sql = "SELECT ... FROM combustibles_movements WHERE movementType = ? ORDER BY movementDate DESC";
      ```
   
   b) Configurar parámetro:
      - Después de crear PreparedStatement
      - Antes de executeQuery()
      - Usa `pstmt.setString(1, type)`
   
   c) Resto del código igual a getAllMovements():
      - Recorrer ResultSet con while
      - Extraer columnas y crear objetos Movement
      - Agregar a lista
      - Retornar lista

4. **Crear método `getMovementsByFuelType(String fuelType)`:**
   
   **Especificaciones:**
   - Similar a getMovementsByType()
   - Filtra por columna `fuelType` en vez de `movementType`
   
   **Query SQL:**
   ```java
   String sql = "SELECT ... FROM combustibles_movements WHERE fuelType = ? ORDER BY movementDate DESC";
   ```
   
   **Desafío:** Implementa este método siguiendo el patrón de getMovementsByType(). ¿Ves el patrón común?

5. **OPCIONAL - Método con múltiples filtros:**
   
   **Desafío avanzado:** Crea un método que filtre por tipo Y combustible:
   
   ```java
   public static List<Movement> searchMovements(String type, String fuelType)
   ```
   
   **Query SQL:**
   ```java
   String sql = "SELECT ... FROM combustibles_movements 
                 WHERE movementType = ? AND fuelType = ? 
                 ORDER BY movementDate DESC";
   ```
   
   **Configurar parámetros:**
   ```java
   pstmt.setString(1, type);      // Primer ?
   pstmt.setString(2, fuelType);  // Segundo ?
   ```

6. **Probar en Main.java:**
   
   **Prueba 1 - Listar todos:**
   ```java
   System.out.println("\n=== TODOS LOS MOVIMIENTOS ===");
   List<Movement> allMovements = MovementService.getAllMovements();
   
   // TÚ debes escribir:
   // - Verificar si la lista está vacía
   // - Recorrer con for-each e imprimir cada movimiento
   // - Mostrar total de movimientos al final
   ```
   
   **Pregunta guía:** ¿Cómo verificas si una lista está vacía? ¿usas `== null` o `.isEmpty()`?
   
   **Prueba 2 - Filtrar por tipo:**
   ```java
   System.out.println("\n=== MOVIMIENTOS DE ENTRADA ===");
   List<Movement> entradas = MovementService.getMovementsByType("ENTRADA");
   
   // TÚ debes escribir el código para imprimir
   ```
   
   **Prueba 3 - Filtrar por combustible:**
   ```java
   System.out.println("\n=== MOVIMIENTOS DE DIESEL ===");
   List<Movement> dieselMovements = MovementService.getMovementsByFuelType("Diesel");
   
   // TÚ debes escribir el código para imprimir
   ```
   
   **Prueba 4 (opcional) - Búsqueda múltiple:**
   ```java
   List<Movement> results = MovementService.searchMovements("ENTRADA", "Diesel");
   ```

7. **Depuración obligatoria:**
   
   **Coloca breakpoints en:**
   - Línea `while (rs.next())` - ver cada iteración
   - Línea donde creas el objeto Movement - inspeccionar valores
   - Línea `movements.add(movement)` - ver cómo crece la lista
   
   **En el debugger:**
   - Inspecciona el ResultSet en cada iteración
   - Ve cómo cambian los valores de las columnas
   - Verifica que los objetos Movement se crean correctamente
   - Cuenta cuántas iteraciones hace el while
   - Verifica el tamaño final de la lista

**✅ Resultado esperado:** 
- Método `getAllMovements()` retorna List<Movement> con todos los registros
- Método `getMovementsByType()` retorna solo movimientos del tipo especificado
- Método `getMovementsByFuelType()` retorna solo movimientos del combustible especificado
- Main.java imprime correctamente todas las listas
- Listas vacías cuando no hay resultados (NO null, NO excepción)
- Movimientos ordenados por fecha descendente (más recientes primero)
- Estructura actualizada:
  ```
  com.forestech/
  └── services/
      └── MovementService.java
          ├── createMovement(Movement) → boolean
          ├── getAllMovements() → List<Movement> (NUEVO)
          ├── getMovementsByType(String) → List<Movement> (NUEVO)
          └── getMovementsByFuelType(String) → List<Movement> (NUEVO)
  ```

**💡 Concepto clave - Retornar lista vacía vs null:**

```java
❌ MAL (retornar null):
public static List<Movement> getAllMovements() {
    try {
        // ...
        if (no hay resultados) {
            return null;  // ❌ Peligroso
        }
    }
}

// En Main.java:
List<Movement> movements = service.getAllMovements();
for (Movement m : movements) {  // ☠️ NullPointerException si movements es null
    System.out.println(m);
}

✅ BIEN (retornar lista vacía):
public static List<Movement> getAllMovements() {
    List<Movement> movements = new ArrayList<>();
    try {
        // ...
        // Si no hay resultados, la lista queda vacía
    }
    return movements;  // ✅ Siempre retorna lista (puede estar vacía)
}

// En Main.java:
List<Movement> movements = service.getAllMovements();
for (Movement m : movements) {  // ✅ Si está vacía, no entra al for (no falla)
    System.out.println(m);
}

// O mejor aún:
if (movements.isEmpty()) {
    System.out.println("No hay movimientos");
} else {
    for (Movement m : movements) {
        System.out.println(m);
    }
}
```

**💡 Concepto clave - Patrón de mapeo ResultSet → Objeto:**

```java
while (rs.next()) {  // Avanza a la siguiente fila
    // 1. Extraer valores de la fila actual
    String id = rs.getString("id");
    String type = rs.getString("movementType");
    double qty = rs.getDouble("quantity");
    // ... etc
    
    // 2. Crear objeto con esos valores
    Movement movement = new Movement(id, type, qty, ...);
    
    // 3. Agregar a la lista
    movements.add(movement);
}
// Al terminar, movements contiene todos los objetos
```

**💡 Concepto clave - Try-with-resources múltiple:**

```java
try (Connection conn = ...;           // Se cierra 3ro (orden inverso)
     PreparedStatement pstmt = ...;   // Se cierra 2do
     ResultSet rs = ...) {            // Se cierra 1ro (último abierto)
    
    // Usar recursos aquí
    
}  // Cierre automático en orden inverso

Equivalente a:
try {
    Connection conn = ...;
    try {
        PreparedStatement pstmt = ...;
        try {
            ResultSet rs = ...;
            // usar recursos
        } finally {
            rs.close();
        }
    } finally {
        pstmt.close();
    }
} finally {
    conn.close();
}

¡Mucho más simple con try-with-resources!
```

**⚠️ CUIDADOS:**

| Problema común | Causa | Solución |
|----------------|-------|----------|
| "Column not found" | Nombre incorrecto en rs.getString() | Verifica nombres exactos en SELECT (mayúsculas/minúsculas) |
| Lista siempre vacía | while nunca entra | Verifica que hay datos en la BD con query manual |
| NullPointerException | Retornaste null en vez de lista vacía | Siempre inicializa `new ArrayList<>()` al inicio |
| Datos incorrectos en objetos | Orden incorrecto al extraer columnas | Verifica que extraes las columnas en el orden del constructor |
| "ResultSet closed" | Intentas usar rs fuera del try | ResultSet solo es válido dentro del try-with-resources |

**🔍 Comparación: getAllMovements vs getMovementsByType:**

```java
// getAllMovements() - SIN filtro:
String sql = "SELECT ... FROM movements ORDER BY date DESC";
// NO hay PreparedStatement con parámetros (puede usar Statement)
// Retorna TODOS los registros

// getMovementsByType() - CON filtro:
String sql = "SELECT ... FROM movements WHERE type = ? ORDER BY date DESC";
pstmt.setString(1, type);  // Configura el filtro
// Retorna solo registros que coinciden con el filtro
```

**📊 Flujo completo de consulta filtrada:**

```
1. Main.java llama al método con parámetro
   List<Movement> entradas = MovementService.getMovementsByType("ENTRADA");

2. MovementService prepara query con placeholder
   String sql = "... WHERE type = ?";

3. Configura el parámetro
   pstmt.setString(1, "ENTRADA");

4. Ejecuta query
   ResultSet rs = pstmt.executeQuery();

5. SQL Server procesa el WHERE y retorna filas filtradas
   Solo filas donde type = 'ENTRADA'

6. while (rs.next()) recorre cada fila filtrada
   Crea objetos Movement y los agrega a la lista

7. Retorna la lista completa
   Main.java puede recorrerla e imprimirla
```

**⏱️ Tiempo estimado:** 3-4 horas

---

## ✅ Checkpoint 4.3: Actualizar vehículos (`UPDATE`)

**Concepto clave:** Validar existencia previa y entender impacto de `WHERE` en UPDATE.

**📍 DÓNDE:** 
- Crear archivo `VehicleService.java` en `src/main/java/com/forestech/services/`

**🎯 PARA QUÉ:** 
Los datos cambian con el tiempo:
- **Corregir errores** en datos capturados
- **Actualizar información** (ej: nuevo número de placa)
- **Modificar estado** (ej: vehículo activo/inactivo)

Sin UPDATE, tendrías que eliminar y crear nuevamente (¡perdiendo historial!)

**🔗 CONEXIÓN FUTURA:**
- En Fase 5, actualizarás cantidades de inventario después de cada movimiento
- En Fase 6, el usuario podrá editar datos desde el menú
- En Fase 7, validarás permisos antes de permitir actualizaciones
- En Fase 8, registrarás auditoría de qué cambió

**Prompts sugeridos:**
```text
"¿Qué pasa si hago UPDATE sin WHERE?"
"¿Cómo verifico que el registro existe antes de actualizar?"
"¿Qué significa que executeUpdate() retorne 0?"
```

**Tareas paso a paso:**

1. **Crear VehicleService:**
   - Similar a MovementService
   - Métodos estáticos por ahora

2. **Crear método `updateVehicle(String id, Vehicle vehicle)`:**
   - Recibe el id del vehículo a actualizar
   - Recibe el objeto Vehicle con los nuevos datos
   - Retorna boolean (true si actualizó, false si no)

3. **Verificar existencia (IMPORTANTE):**
   - Antes de actualizar, ejecuta SELECT COUNT(*) WHERE id = ?
   - Si retorna 0, el vehículo no existe
   - Imprime mensaje y retorna false

4. **Construir query UPDATE:**
   - UPDATE combustibles_vehicles SET plate = ?, model = ?, category = ? WHERE id = ?
   - Usa placeholders para todos los valores

5. **Ejecutar UPDATE:**
   - Asigna valores con setString
   - Ejecuta executeUpdate()
   - Verifica filas afectadas (debe ser 1)

6. **Probar en Main.java:**
   - Inserta un vehículo
   - Modifícalo con updateVehicle
   - Verifica en SQL Server que cambió
   - Intenta actualizar un id que no existe

**✅ Resultado esperado:** 
- Actualizar vehículo existente exitosamente
- Rechazar actualización si el id no existe
- Mensaje claro en ambos casos

**⚠️ PELIGRO:** UPDATE sin WHERE actualiza TODAS las filas. Siempre verifica tu query.

**💡 Buena práctica:** Imprime cuántos campos cambiaron (puedes comparar antes/después).

**⏱️ Tiempo estimado:** 2-3 horas

---

## ✅ Checkpoint 4.4: Eliminar con validación (`DELETE`)

**Concepto clave:** Preservar integridad referencial antes de eliminar.

**📍 DÓNDE:** 
- Clase `SupplierService` en nuevo archivo `SupplierService.java`
- O agregar método en MovementService

**🎯 PARA QUÉ:** 
Eliminar datos es PELIGROSO:
- **No se puede deshacer** fácilmente
- **Puede romper relaciones** con otras tablas
- **Puede perder información valiosa** para auditoría

Por eso necesitas validaciones estrictas.

**🔗 CONEXIÓN FUTURA:**
- En Fase 5, implementarás "soft delete" (marcar como inactivo en vez de borrar)
- En Fase 7, agregarás confirmación del usuario antes de eliminar
- En Fase 8, registrarás quién eliminó y cuándo (auditoría)
- En Fase 9, los reportes solo mostrarán registros activos

**Prompts sugeridos:**
```text
"Explícame integridad referencial y qué podría romperse si borro sin validar."
"¿Qué es un DELETE en cascada y cuándo conviene usarlo?"
"¿Qué es soft delete y cuáles son sus ventajas?"
```

**Tareas paso a paso:**

1. **Crear método `deleteSupplier(String id)`:**
   - Recibe el id del proveedor a eliminar
   - Retorna boolean

2. **Validar dependencias (CRÍTICO):**
   - Antes de borrar, consulta: SELECT COUNT(*) FROM combustibles_movements WHERE supplierId = ?
   - Si hay movimientos asociados, NO eliminar
   - Imprime mensaje: "No se puede eliminar, tiene X movimientos asociados"
   - Retorna false

3. **Si no hay dependencias:**
   - Construye query DELETE con WHERE id = ?
   - Ejecuta executeUpdate()
   - Verifica filas afectadas

4. **Considerar alternativa soft delete:**
   - En vez de DELETE, usa UPDATE para cambiar un campo isActive = false
   - Ventaja: conservas el historial

5. **Probar en Main.java:**
   - Intenta eliminar un proveedor CON movimientos (debe rechazar)
   - Intenta eliminar un proveedor SIN movimientos (debe permitir)
   - Verifica en SQL Server el resultado

**✅ Resultado esperado:** 
- Proteger integridad de datos rechazando eliminaciones peligrosas
- Eliminar solo cuando es seguro
- Mensajes claros sobre por qué se rechaza

**💡 Reflexión:** ¿Qué es mejor para Forestech: DELETE real o soft delete? Discútelo con tu IA.

**⏱️ Tiempo estimado:** 2-3 horas

---

## 🧪 Refuerzos de calidad

**Pruebas manuales tras cada operación:**
- Consulta la tabla en SQL Server para verificar estado
- Compara lo que ves en la BD con lo que esperabas
- Verifica conteo de filas antes y después

**Registro de aprendizaje:**
- Anota SQL ejecutado, filas afectadas y resultados esperados vs reales
- Documenta errores encontrados y cómo los resolviste
- Crea script `cleanup.sql` para restaurar datos de prueba

**Testing inicial:**
- Prepara tu primer test JUnit simple (aunque se conecte a BD real)
- Valida que insertar un Movement retorna true
- Valida que insertar con datos inválidos retorna false

---

## ✅ Checklist de salida de Fase 4

- [ ] Domino PreparedStatement y sé cómo evita SQL Injection
- [ ] Puedo explicar la diferencia entre executeQuery y executeUpdate
- [ ] Mis métodos INSERT guardan objetos Java en la BD correctamente
- [ ] Mis métodos SELECT retornan List<Objeto> correctamente mapeados
- [ ] Mis métodos UPDATE verifican existencia antes de actualizar
- [ ] Mis métodos DELETE validan integridad referencial antes de borrar
- [ ] Mis servicios retornan colecciones vacías en vez de null
- [ ] Documenté en JAVA_LEARNING_LOG.md decisiones, casos de prueba y aprendizajes

**🎯 Desafío final:** 
Crea un método `getMovementsByDateRange(String startDate, String endDate)` que retorne movimientos entre dos fechas.

**📊 Tabla de métodos CRUD completados:**

| Servicio | CREATE | READ | UPDATE | DELETE |
|----------|--------|------|--------|--------|
| MovementService | ✅ | ✅ | ⚪ | ⚪ |
| VehicleService | ⚪ | ⚪ | ✅ | ⚪ |
| SupplierService | ⚪ | ⚪ | ⚪ | ✅ |

**Objetivo:** Completar todas las operaciones para al menos MovementService.

---

## 🚀 Próximo paso: FASE 5 - Lógica de Negocio

En la siguiente fase aprenderás a:
- Implementar reglas de negocio (no permitir salidas mayores al inventario)
- Manejar transacciones (varias operaciones que deben ser atómicas)
- Calcular inventario actual dinámicamente
- Validar datos antes de guardar
- Crear métodos de servicio más complejos

**¿Por qué lógica de negocio?** Hasta ahora solo guardas/lees datos. La lógica de negocio asegura que los datos sean VÁLIDOS y CONSISTENTES según las reglas de Forestech (ej: no vender más combustible del que tienes).

**⏱️ Tiempo total Fase 4:** 10-15 horas distribuidas en 2 semanas
