# ğŸ› ï¸ FASE 4: OPERACIONES CRUD (Semanas 6-7)

> Objetivo general: dominar operaciones completas de base de datos (CREATE, READ, UPDATE, DELETE) usando PreparedStatement con validaciones y buenas prÃ¡cticas de seguridad.

---

## ğŸ§  Antes de empezar

- ğŸ“š **Fundamentos SQL CRUD:** Repasa en SQL Server Management Studio:
  - INSERT INTO con mÃºltiples columnas y valores
  - SELECT con WHERE y diferentes tipos de filtros
  - UPDATE con WHERE (Â¡NUNCA sin WHERE!)
  - DELETE con WHERE y validaciÃ³n de integridad referencial
- ğŸ“ **Documenta tus pruebas SQL:** Ejecuta manualmente cada operaciÃ³n en SQL Server y anota los resultados en `JAVA_LEARNING_LOG.md`
- ğŸ” **Seguridad:** Investiga quÃ© es SQL Injection y por quÃ© PreparedStatement es obligatorio
- ğŸ” **Git loop:** Al completar cada checkpoint crea un commit (`git commit -m "fase4 checkpoint 4.1"`)
- ğŸ¯ **CRUD COMPLETO:** CrearÃ¡s services para cada entidad siguiendo un patrÃ³n consistente
- âœï¸ **APRENDIZAJE ACTIVO:** RecibirÃ¡s DIRECTIVAS y especificaciones. TÃš escribirÃ¡s el cÃ³digo y entenderÃ¡s cada operaciÃ³n.

---

## ğŸ“¦ ESTRUCTURA AL TERMINAR FASE 3

Antes de empezar Fase 4, debes tener esta estructura:

```
com.forestech/
â”œâ”€â”€ Main.java
â”œâ”€â”€ AppConfig.java
â”œâ”€â”€ MenuHelper.java
â”œâ”€â”€ DataDisplay.java
â”œâ”€â”€ InputHelper.java
â”œâ”€â”€ config/
â”‚   â””â”€â”€ DatabaseConnection.java
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ Movement.java
â”‚   â”œâ”€â”€ Vehicle.java
â”‚   â”œâ”€â”€ Supplier.java
â”‚   â””â”€â”€ Product.java
â””â”€â”€ services/
    â””â”€â”€ ProductService.java (solo SELECT)
```

**Verifica que ProductService ya tenga:**
- `getAllProducts()` - retorna List<Product>
- `getProductById(String id)` - retorna Product con PreparedStatement
- `getProductsByType(String type)` - retorna List<Product> filtrada

---

## ğŸ¯ ESTRUCTURA AL TERMINAR FASE 4

Al finalizar esta fase tendrÃ¡s:

```
com.forestech/
â”œâ”€â”€ Main.java (pruebas CRUD completas)
â”œâ”€â”€ AppConfig.java
â”œâ”€â”€ MenuHelper.java
â”œâ”€â”€ DataDisplay.java
â”œâ”€â”€ InputHelper.java
â”œâ”€â”€ config/
â”‚   â””â”€â”€ DatabaseConnection.java
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ Movement.java
â”‚   â”œâ”€â”€ Vehicle.java
â”‚   â”œâ”€â”€ Supplier.java
â”‚   â””â”€â”€ Product.java
â”œâ”€â”€ managers/
â”‚   â””â”€â”€ MovementManager.java (DEPRECATED - ahora se usa MovementService)
â””â”€â”€ services/
    â”œâ”€â”€ MovementService.java (NUEVO - CRUD completo)
    â”œâ”€â”€ VehicleService.java (NUEVO - CRUD completo)
    â”œâ”€â”€ SupplierService.java (NUEVO - CRUD completo)
    â””â”€â”€ ProductService.java (EXTENDIDO - ahora con INSERT, UPDATE, DELETE)
```

**FilosofÃ­a de la fase:**
- **Services completos:** Cada service tendrÃ¡ las 4 operaciones CRUD
- **Validaciones previas:** Verificar existencia antes de UPDATE/DELETE
- **Integridad referencial:** No permitir DELETE si hay relaciones
- **PreparedStatement siempre:** Para TODAS las operaciones (no solo SELECT)
- **Manejo de errores:** try-catch apropiado en cada mÃ©todo
- **Retornos consistentes:** boolean para operaciones de escritura, objetos/listas para lectura

---

## âœ… Checkpoint 4.1: Insertar movimientos (INSERT)

**Concepto clave:** PreparedStatement con placeholders (?) previene SQL Injection y permite insertar datos de forma segura desde objetos Java a la base de datos.

**ğŸ“ DÃ“NDE:** 
- **Crear archivo:** `MovementService.java` en `forestech-cli-java/src/main/java/com/forestech/services/`
- **Modificar:** `Main.java` para PROBAR la inserciÃ³n

**ğŸ¯ PARA QUÃ‰:** 
Hasta Fase 3 solo LEES datos (SELECT). Ahora necesitas CREAR datos:
- âœ… **Persistir movimientos** creados en Java hacia SQL Server
- âœ… **Registrar operaciones** del usuario en la aplicaciÃ³n
- âœ… **Evitar perder datos** cuando cierras la aplicaciÃ³n
- âœ… **Completar el ciclo de datos:** crear objetos Java â†’ guardar en BD â†’ recuperar despuÃ©s

**Diferencia con Fase 3:**
```
FASE 3:
BD (datos ya existen) â†’ SELECT â†’ Java (lee y muestra)

FASE 4:
Java (crea objeto Movement) â†’ INSERT â†’ BD (guarda permanentemente)
```

**ğŸ”— CONEXIÃ“N FUTURA:**
- **Fase 5:** AgregarÃ¡s validaciones de negocio antes de insertar (verificar inventario disponible)
- **Fase 6:** El menÃº interactivo llamarÃ¡ a createMovement() cuando el usuario registre operaciones
- **Fase 7:** ManejarÃ¡s errores especÃ­ficos (duplicados, violaciones de FK)
- **Fase 9:** Los movimientos insertados aparecerÃ¡n en reportes y anÃ¡lisis

**ğŸ“ AnalogÃ­a:**
- **SELECT (Fase 3):** Leer un libro de la biblioteca
- **INSERT (Fase 4):** Escribir un nuevo libro y agregarlo a la biblioteca

**Prompts sugeridos:**
```text
"Â¿CuÃ¡l es la diferencia entre executeQuery() y executeUpdate()?"
"ExplÃ­came paso a paso cÃ³mo PreparedStatement previene SQL Injection."
"Â¿Por quÃ© executeUpdate() retorna un int? Â¿QuÃ© significa ese nÃºmero?"
"Â¿En quÃ© orden se asignan los valores a los placeholders (?)?"
"Â¿QuÃ© pasa si olvido asignar un valor a un placeholder?"
```

**Tareas paso a paso:**

1. **Crear la clase MovementService:**
   
   - Clic derecho en paquete `services` â†’ New â†’ Java Class â†’ "MovementService"
   - Declarar como clase pÃºblica
   - Constructor privado (es una utility class con mÃ©todos estÃ¡ticos por ahora)
   
   **Pregunta guÃ­a:** Â¿Por quÃ© usamos mÃ©todos estÃ¡ticos en vez de crear instancias?

2. **Imports necesarios (boilerplate permitido):**
   
   ```java
   import com.forestech.config.DatabaseConnection;
   import com.forestech.models.Movement;
   import java.sql.Connection;
   import java.sql.PreparedStatement;
   import java.sql.SQLException;
   ```

3. **Crear mÃ©todo `createMovement(Movement movement)`:**
   
   **Especificaciones:**
   - Modificador: `public static`
   - Tipo de retorno: `boolean` (true si se insertÃ³, false si fallÃ³)
   - ParÃ¡metros: `Movement movement` (el objeto a guardar)
   
   **Pregunta guÃ­a:** Â¿Por quÃ© retornar boolean en vez de void?

4. **Definir la query SQL INSERT:**
   
   **Especificaciones (TÃš debes escribir la query):**
   - INSERT INTO la tabla `combustibles_movements`
   - Columnas a insertar: id, movementType, fuelType, quantity, unitPrice, movementDate
   - Usa placeholders (?) para TODOS los valores
   - NO uses concatenaciÃ³n de strings
   
   **Formato:**
   ```java
   String sql = "INSERT INTO tabla (col1, col2, col3) VALUES (?, ?, ?)";
   ```
   
   **Pregunta guÃ­a:** Â¿Por quÃ© usar placeholders en vez de concatenar valores directamente?
   
   **âš ï¸ PELIGRO - SQL Injection:**
   ```java
   // âŒ NUNCA HACER ESTO:
   String sql = "INSERT INTO movements VALUES ('" + movement.getId() + "')";
   // â˜ ï¸ Vulnerable a SQL Injection
   
   // âœ… SIEMPRE HACER ESTO:
   String sql = "INSERT INTO movements VALUES (?)";
   pstmt.setString(1, movement.getId());
   // âœ… Seguro contra SQL Injection
   ```

5. **Implementar la lÃ³gica de inserciÃ³n:**
   
   **Estructura del mÃ©todo (TÃš completas la implementaciÃ³n):**
   
   a) Usar try-with-resources para Connection y PreparedStatement:
      ```java
      try (Connection conn = DatabaseConnection.getConnection();
           PreparedStatement pstmt = conn.prepareStatement(sql)) {
          
          // Configurar parÃ¡metros aquÃ­
          
      } catch (SQLException e) {
          // Manejo de error aquÃ­
      }
      ```
   
   b) Configurar los parÃ¡metros del PreparedStatement:
      - Usa los getters del objeto Movement para obtener los valores
      - Asigna cada valor al placeholder correspondiente usando:
        - `pstmt.setString(indice, valor)` para Strings
        - `pstmt.setDouble(indice, valor)` para doubles
      - El Ã­ndice empieza en 1 (no en 0)
      
   **Ejemplo del primer parÃ¡metro:**
   ```java
   pstmt.setString(1, movement.getId());  // Primer ? (id)
   ```
   
   **TÃš debes configurar los demÃ¡s:**
   - Segundo ? (movementType)
   - Tercero ? (fuelType)
   - Cuarto ? (quantity)
   - Quinto ? (unitPrice)
   - Sexto ? (movementDate)
   
   **Pregunta guÃ­a:** Â¿QuÃ© pasa si el orden de los setString no coincide con el orden de los ? en la query?
   
   c) Ejecutar la inserciÃ³n:
      ```java
      int rowsAffected = pstmt.executeUpdate();
      ```
      
   **Pregunta guÃ­a:** Â¿Por quÃ© usamos executeUpdate() y no executeQuery()?
   
   d) Verificar el resultado:
      - Si `rowsAffected == 1`: inserciÃ³n exitosa â†’ retornar true
      - Si `rowsAffected == 0`: no se insertÃ³ nada â†’ imprimir mensaje y retornar false
      - Imprime mensaje de confirmaciÃ³n con los datos insertados
   
   e) En el bloque catch:
      - Imprimir mensaje de error descriptivo
      - Imprimir el mensaje de la excepciÃ³n: `e.getMessage()`
      - Retornar false

6. **Probar en Main.java:**
   
   **Crear prueba de inserciÃ³n:**
   
   ```java
   System.out.println("\n=== PRUEBA DE INSERCIÃ“N DE MOVEMENT ===");
   
   // TÃš debes escribir:
   // 1. Crear un objeto Movement con datos de prueba
   //    - Usa el constructor que ya existe en Movement.java
   //    - Ejemplo: tipo "ENTRADA", combustible "Diesel", cantidad 1000.0
   // 2. Llamar a MovementService.createMovement(movement)
   // 3. Verificar el resultado (true/false)
   // 4. Imprimir mensaje segÃºn el resultado
   ```
   
   **VerificaciÃ³n manual en SQL Server:**
   - Abre SQL Server Management Studio
   - Ejecuta: `SELECT * FROM combustibles_movements ORDER BY movementDate DESC`
   - Verifica que tu movimiento aparece con los datos correctos

7. **DepuraciÃ³n obligatoria:**
   
   **Coloca breakpoints en:**
   - LÃ­nea donde creas el PreparedStatement
   - LÃ­nea donde ejecutas executeUpdate()
   - LÃ­nea dentro del catch (para ver errores)
   
   **En el debugger:**
   - Inspecciona el objeto `movement` antes de insertar
   - EvalÃºa `pstmt.toString()` para ver la query con valores
   - Verifica el valor de `rowsAffected` despuÃ©s de executeUpdate()
   - Si falla, revisa el mensaje de la SQLException

**âœ… Resultado esperado:** 
- MÃ©todo `createMovement()` implementado en MovementService.java
- Main.java crea un Movement y lo guarda exitosamente
- Ver mensaje de confirmaciÃ³n en consola con los datos insertados
- Verificar en SQL Server que el registro existe con los datos correctos
- Si hay error, ver mensaje descriptivo del problema
- Estructura actualizada:
  ```
  com.forestech/
  â”œâ”€â”€ Main.java (con prueba de inserciÃ³n)
  â”œâ”€â”€ config/
  â”‚   â””â”€â”€ DatabaseConnection.java
  â”œâ”€â”€ models/
  â”‚   â””â”€â”€ Movement.java
  â””â”€â”€ services/
      â”œâ”€â”€ ProductService.java
      â””â”€â”€ MovementService.java (NUEVO)
  ```

**ğŸ’¡ Concepto clave - executeUpdate() vs executeQuery():**

```
executeQuery():
- Usado para SELECT (consultas que RETORNAN datos)
- Retorna ResultSet con los datos
- NO modifica la base de datos

executeUpdate():
- Usado para INSERT, UPDATE, DELETE (operaciones que MODIFICAN datos)
- Retorna int (nÃºmero de filas afectadas)
- SÃ modifica la base de datos
```

**ğŸ’¡ Concepto clave - Orden de parÃ¡metros:**

```
SQL: "INSERT INTO movements (id, type, fuel) VALUES (?, ?, ?)"
                                                      â†‘   â†‘   â†‘
                                                      1   2   3

Java:
pstmt.setString(1, movement.getId());      // â†’ Primer ?
pstmt.setString(2, movement.getType());    // â†’ Segundo ?
pstmt.setString(3, movement.getFuel());    // â†’ Tercer ?

âŒ SI CAMBIAS EL ORDEN, los datos se guardan en las columnas incorrectas
```

**ğŸ’¡ Concepto clave - try-with-resources:**

```
Â¿Por quÃ© usar try-with-resources?

SIN try-with-resources (antiguo):
Connection conn = null;
PreparedStatement pstmt = null;
try {
    conn = DatabaseConnection.getConnection();
    pstmt = conn.prepareStatement(sql);
    // ...
} finally {
    if (pstmt != null) pstmt.close();  // CÃ³digo repetitivo
    if (conn != null) conn.close();
}

CON try-with-resources (moderno):
try (Connection conn = DatabaseConnection.getConnection();
     PreparedStatement pstmt = conn.prepareStatement(sql)) {
    // ...
}  // âœ… Se cierran automÃ¡ticamente en orden inverso

Ventajas:
- MÃ¡s conciso y legible
- Cierre garantizado incluso si hay excepciÃ³n
- Orden de cierre automÃ¡tico (Ãºltimo abierto, primero cerrado)
```

**âš ï¸ CUIDADOS:**

| Problema comÃºn | Causa | SoluciÃ³n |
|----------------|-------|----------|
| "Parameter index out of range" | Ãndice incorrecto o placeholders mal contados | Cuenta los ? en tu query y verifica Ã­ndices 1, 2, 3... |
| "Column count doesn't match" | Diferente nÃºmero de columnas vs valores | Verifica que cada columna en INSERT tenga su ? correspondiente |
| "Cannot insert NULL" | No asignaste valor a un placeholder | Verifica que llamaste setString/setDouble para TODOS los ? |
| rowsAffected = 0 | Query no fallÃ³ pero no insertÃ³ | Verifica que la tabla existe y no hay constraints que bloqueen |
| SQLException sin mensaje claro | Error en la query SQL | Imprime la query completa y pruÃ©bala en SQL Server Management Studio |

**ğŸ” DepuraciÃ³n - Ver query compilada:**

En el debugger, evalÃºa:
```java
pstmt.toString()
```

VerÃ¡s algo como:
```
PreparedStatement: INSERT INTO movements VALUES ('M001', 'ENTRADA', 'Diesel', 1000.0, ...)
```

Esto te muestra cÃ³mo se ve la query con los parÃ¡metros ya sustituidos. Puedes copiarla y probarla directamente en SQL Server.

**ğŸ“Š Flujo completo de INSERT:**

```
1. Java crea objeto Movement
   Movement m = new Movement("ENTRADA", "Diesel", 1000.0, 3.5);

2. Pasa el objeto a MovementService
   boolean success = MovementService.createMovement(m);

3. MovementService extrae datos del objeto
   pstmt.setString(1, m.getId());
   pstmt.setString(2, m.getType());
   ... etc

4. executeUpdate() envÃ­a la query a SQL Server
   int rows = pstmt.executeUpdate();

5. SQL Server procesa el INSERT
   - Valida constraints (PK, FK, NOT NULL)
   - Inserta la fila si todo es vÃ¡lido

6. Retorna nÃºmero de filas afectadas
   rows = 1 (Ã©xito) o 0 (no se insertÃ³)

7. MovementService retorna boolean
   return rows == 1;
```

**â±ï¸ Tiempo estimado:** 3-4 horas

---

## âœ… Checkpoint 4.2: Consultas filtradas (SELECT WHERE)

**Concepto clave:** Combinar PreparedStatement parametrizado con mapeo de ResultSet a objetos permite crear queries flexibles y seguras que retornan listas de datos filtrados.

**ğŸ“ DÃ“NDE:** 
- **Modificar:** `MovementService.java` (agregar nuevos mÃ©todos de lectura)
- **Main.java:** Para PROBAR los filtros

**ğŸ¯ PARA QUÃ‰:** 
En Checkpoint 4.1 insertaste datos. Ahora necesitas consultarlos de forma inteligente:
- âŒ **NO siempre quieres TODOS los movimientos** (pueden ser miles)
- âœ… **Filtrar por tipo:** Solo ENTRADAS o solo SALIDAS
- âœ… **Filtrar por combustible:** Solo movimientos de Diesel
- âœ… **Ordenar resultados:** Los mÃ¡s recientes primero
- âœ… **BÃºsquedas especÃ­ficas:** Movimientos de una fecha concreta

**Diferencia con ProductService de Fase 3:**
```
ProductService (Fase 3):
- LeÃ­as productos que ya existÃ­an en la BD
- Solo SELECT, sin filtros complejos

MovementService (Fase 4):
- Lees movimientos que TÃš insertaste con Java
- SELECT con WHERE, ORDER BY, mÃºltiples filtros
- PatrÃ³n completo de mapeo ResultSet â†’ List<Objeto>
```

**ğŸ”— CONEXIÃ“N FUTURA:**
- **Fase 5:** CalcularÃ¡s inventario actual consultando movimientos con estos mÃ©todos
- **Fase 6:** El menÃº mostrarÃ¡ movimientos filtrados por tipo, fecha o combustible
- **Fase 7:** ValidarÃ¡s datos consultando movimientos existentes
- **Fase 9:** GenerarÃ¡s reportes consultando por rangos de fechas

**ğŸ“ AnalogÃ­a:**
- **getAllMovements():** "TrÃ¡eme todos los libros de la biblioteca"
- **getMovementsByType("ENTRADA"):** "TrÃ¡eme solo los libros de ciencia ficciÃ³n"
- **getMovementsByFuelType("Diesel"):** "TrÃ¡eme solo los libros del autor Asimov"

**Prompts sugeridos:**
```text
"Â¿CÃ³mo mapeo un ResultSet a un objeto Movement paso a paso?"
"Â¿Por quÃ© es mejor retornar List<Movement> que imprimir directamente en el Service?"
"Â¿QuÃ© hago si la consulta no retorna resultados? Â¿Retorno null o lista vacÃ­a?"
"Â¿CÃ³mo recorro un ResultSet y creo objetos al mismo tiempo?"
"Â¿Por quÃ© usar ORDER BY en la query y no ordenar en Java?"
```

**Tareas paso a paso:**

1. **Crear mÃ©todo `getAllMovements()`:**
   
   **Especificaciones:**
   - Modificador: `public static`
   - Tipo de retorno: `List<Movement>`
   - ParÃ¡metros: ninguno
   - Retorna lista vacÃ­a si no hay movimientos
   
   **Pregunta guÃ­a:** Â¿Por quÃ© empezamos con getAllMovements() antes de los filtros?

2. **ImplementaciÃ³n de getAllMovements():**
   
   **Estructura del mÃ©todo (TÃš la implementas):**
   
   a) Crear lista vacÃ­a al inicio:
      ```java
      List<Movement> movements = new ArrayList<>();
      ```
      
   b) Definir query SQL:
      - SELECT de todas las columnas necesarias
      - FROM combustibles_movements
      - ORDER BY movementDate DESC (mÃ¡s recientes primero)
      - SIN WHERE (queremos todos)
      
   c) Imports necesarios:
      ```java
      import java.util.List;
      import java.util.ArrayList;
      ```
   
   d) Usar try-with-resources:
      ```java
      try (Connection conn = DatabaseConnection.getConnection();
           PreparedStatement pstmt = conn.prepareStatement(sql);
           ResultSet rs = pstmt.executeQuery()) {
          
          // CÃ³digo de mapeo aquÃ­
          
      } catch (SQLException e) {
          // Manejo de error
      }
      ```
   
   **Pregunta guÃ­a:** Â¿Por quÃ© ResultSet tambiÃ©n va en try-with-resources?
   
   e) Recorrer ResultSet y mapear a objetos:
      ```java
      while (rs.next()) {
          // TÃš debes implementar:
          // 1. Extraer cada columna del ResultSet
          // 2. Crear objeto Movement con esos datos
          // 3. Agregar el objeto a la lista
      }
      ```
   
   **Ejemplo de extracciÃ³n de columnas:**
   ```java
   String id = rs.getString("id");
   String type = rs.getString("movementType");
   // ... continÃºa con las demÃ¡s columnas
   ```
   
   **Pregunta guÃ­a:** Â¿Los nombres en getString() deben coincidir con los nombres en la query SELECT?
   
   f) Retornar la lista (puede estar vacÃ­a):
      ```java
      return movements;
      ```
   
   g) En el catch:
      - Imprimir mensaje de error
      - Retornar lista vacÃ­a (NO null)
      
   **Pregunta guÃ­a:** Â¿Por quÃ© retornar lista vacÃ­a y no null cuando hay error?

3. **Crear mÃ©todo `getMovementsByType(String type)`:**
   
   **Especificaciones:**
   - Modificador: `public static`
   - Tipo de retorno: `List<Movement>`
   - ParÃ¡metros: `String type` ("ENTRADA" o "SALIDA")
   - Retorna lista filtrada o vacÃ­a
   
   **ImplementaciÃ³n (TÃš la haces):**
   
   a) Query SQL con WHERE:
      ```java
      String sql = "SELECT ... FROM combustibles_movements WHERE movementType = ? ORDER BY movementDate DESC";
      ```
   
   b) Configurar parÃ¡metro:
      - DespuÃ©s de crear PreparedStatement
      - Antes de executeQuery()
      - Usa `pstmt.setString(1, type)`
   
   c) Resto del cÃ³digo igual a getAllMovements():
      - Recorrer ResultSet con while
      - Extraer columnas y crear objetos Movement
      - Agregar a lista
      - Retornar lista

4. **Crear mÃ©todo `getMovementsByFuelType(String fuelType)`:**
   
   **Especificaciones:**
   - Similar a getMovementsByType()
   - Filtra por columna `fuelType` en vez de `movementType`
   
   **Query SQL:**
   ```java
   String sql = "SELECT ... FROM combustibles_movements WHERE fuelType = ? ORDER BY movementDate DESC";
   ```
   
   **DesafÃ­o:** Implementa este mÃ©todo siguiendo el patrÃ³n de getMovementsByType(). Â¿Ves el patrÃ³n comÃºn?

5. **OPCIONAL - MÃ©todo con mÃºltiples filtros:**
   
   **DesafÃ­o avanzado:** Crea un mÃ©todo que filtre por tipo Y combustible:
   
   ```java
   public static List<Movement> searchMovements(String type, String fuelType)
   ```
   
   **Query SQL:**
   ```java
   String sql = "SELECT ... FROM combustibles_movements 
                 WHERE movementType = ? AND fuelType = ? 
                 ORDER BY movementDate DESC";
   ```
   
   **Configurar parÃ¡metros:**
   ```java
   pstmt.setString(1, type);      // Primer ?
   pstmt.setString(2, fuelType);  // Segundo ?
   ```

6. **Probar en Main.java:**
   
   **Prueba 1 - Listar todos:**
   ```java
   System.out.println("\n=== TODOS LOS MOVIMIENTOS ===");
   List<Movement> allMovements = MovementService.getAllMovements();
   
   // TÃš debes escribir:
   // - Verificar si la lista estÃ¡ vacÃ­a
   // - Recorrer con for-each e imprimir cada movimiento
   // - Mostrar total de movimientos al final
   ```
   
   **Pregunta guÃ­a:** Â¿CÃ³mo verificas si una lista estÃ¡ vacÃ­a? Â¿usas `== null` o `.isEmpty()`?
   
   **Prueba 2 - Filtrar por tipo:**
   ```java
   System.out.println("\n=== MOVIMIENTOS DE ENTRADA ===");
   List<Movement> entradas = MovementService.getMovementsByType("ENTRADA");
   
   // TÃš debes escribir el cÃ³digo para imprimir
   ```
   
   **Prueba 3 - Filtrar por combustible:**
   ```java
   System.out.println("\n=== MOVIMIENTOS DE DIESEL ===");
   List<Movement> dieselMovements = MovementService.getMovementsByFuelType("Diesel");
   
   // TÃš debes escribir el cÃ³digo para imprimir
   ```
   
   **Prueba 4 (opcional) - BÃºsqueda mÃºltiple:**
   ```java
   List<Movement> results = MovementService.searchMovements("ENTRADA", "Diesel");
   ```

7. **DepuraciÃ³n obligatoria:**
   
   **Coloca breakpoints en:**
   - LÃ­nea `while (rs.next())` - ver cada iteraciÃ³n
   - LÃ­nea donde creas el objeto Movement - inspeccionar valores
   - LÃ­nea `movements.add(movement)` - ver cÃ³mo crece la lista
   
   **En el debugger:**
   - Inspecciona el ResultSet en cada iteraciÃ³n
   - Ve cÃ³mo cambian los valores de las columnas
   - Verifica que los objetos Movement se crean correctamente
   - Cuenta cuÃ¡ntas iteraciones hace el while
   - Verifica el tamaÃ±o final de la lista

**âœ… Resultado esperado:** 
- MÃ©todo `getAllMovements()` retorna List<Movement> con todos los registros
- MÃ©todo `getMovementsByType()` retorna solo movimientos del tipo especificado
- MÃ©todo `getMovementsByFuelType()` retorna solo movimientos del combustible especificado
- Main.java imprime correctamente todas las listas
- Listas vacÃ­as cuando no hay resultados (NO null, NO excepciÃ³n)
- Movimientos ordenados por fecha descendente (mÃ¡s recientes primero)
- Estructura actualizada:
  ```
  com.forestech/
  â””â”€â”€ services/
      â””â”€â”€ MovementService.java
          â”œâ”€â”€ createMovement(Movement) â†’ boolean
          â”œâ”€â”€ getAllMovements() â†’ List<Movement> (NUEVO)
          â”œâ”€â”€ getMovementsByType(String) â†’ List<Movement> (NUEVO)
          â””â”€â”€ getMovementsByFuelType(String) â†’ List<Movement> (NUEVO)
  ```

**ğŸ’¡ Concepto clave - Retornar lista vacÃ­a vs null:**

```java
âŒ MAL (retornar null):
public static List<Movement> getAllMovements() {
    try {
        // ...
        if (no hay resultados) {
            return null;  // âŒ Peligroso
        }
    }
}

// En Main.java:
List<Movement> movements = service.getAllMovements();
for (Movement m : movements) {  // â˜ ï¸ NullPointerException si movements es null
    System.out.println(m);
}

âœ… BIEN (retornar lista vacÃ­a):
public static List<Movement> getAllMovements() {
    List<Movement> movements = new ArrayList<>();
    try {
        // ...
        // Si no hay resultados, la lista queda vacÃ­a
    }
    return movements;  // âœ… Siempre retorna lista (puede estar vacÃ­a)
}

// En Main.java:
List<Movement> movements = service.getAllMovements();
for (Movement m : movements) {  // âœ… Si estÃ¡ vacÃ­a, no entra al for (no falla)
    System.out.println(m);
}

// O mejor aÃºn:
if (movements.isEmpty()) {
    System.out.println("No hay movimientos");
} else {
    for (Movement m : movements) {
        System.out.println(m);
    }
}
```

**ğŸ’¡ Concepto clave - PatrÃ³n de mapeo ResultSet â†’ Objeto:**

```java
while (rs.next()) {  // Avanza a la siguiente fila
    // 1. Extraer valores de la fila actual
    String id = rs.getString("id");
    String type = rs.getString("movementType");
    double qty = rs.getDouble("quantity");
    // ... etc
    
    // 2. Crear objeto con esos valores
    Movement movement = new Movement(id, type, qty, ...);
    
    // 3. Agregar a la lista
    movements.add(movement);
}
// Al terminar, movements contiene todos los objetos
```

**ğŸ’¡ Concepto clave - Try-with-resources mÃºltiple:**

```java
try (Connection conn = ...;           // Se cierra 3ro (orden inverso)
     PreparedStatement pstmt = ...;   // Se cierra 2do
     ResultSet rs = ...) {            // Se cierra 1ro (Ãºltimo abierto)
    
    // Usar recursos aquÃ­
    
}  // Cierre automÃ¡tico en orden inverso

Equivalente a:
try {
    Connection conn = ...;
    try {
        PreparedStatement pstmt = ...;
        try {
            ResultSet rs = ...;
            // usar recursos
        } finally {
            rs.close();
        }
    } finally {
        pstmt.close();
    }
} finally {
    conn.close();
}

Â¡Mucho mÃ¡s simple con try-with-resources!
```

**âš ï¸ CUIDADOS:**

| Problema comÃºn | Causa | SoluciÃ³n |
|----------------|-------|----------|
| "Column not found" | Nombre incorrecto en rs.getString() | Verifica nombres exactos en SELECT (mayÃºsculas/minÃºsculas) |
| Lista siempre vacÃ­a | while nunca entra | Verifica que hay datos en la BD con query manual |
| NullPointerException | Retornaste null en vez de lista vacÃ­a | Siempre inicializa `new ArrayList<>()` al inicio |
| Datos incorrectos en objetos | Orden incorrecto al extraer columnas | Verifica que extraes las columnas en el orden del constructor |
| "ResultSet closed" | Intentas usar rs fuera del try | ResultSet solo es vÃ¡lido dentro del try-with-resources |

**ğŸ” ComparaciÃ³n: getAllMovements vs getMovementsByType:**

```java
// getAllMovements() - SIN filtro:
String sql = "SELECT ... FROM movements ORDER BY date DESC";
// NO hay PreparedStatement con parÃ¡metros (puede usar Statement)
// Retorna TODOS los registros

// getMovementsByType() - CON filtro:
String sql = "SELECT ... FROM movements WHERE type = ? ORDER BY date DESC";
pstmt.setString(1, type);  // Configura el filtro
// Retorna solo registros que coinciden con el filtro
```

**ğŸ“Š Flujo completo de consulta filtrada:**

```
1. Main.java llama al mÃ©todo con parÃ¡metro
   List<Movement> entradas = MovementService.getMovementsByType("ENTRADA");

2. MovementService prepara query con placeholder
   String sql = "... WHERE type = ?";

3. Configura el parÃ¡metro
   pstmt.setString(1, "ENTRADA");

4. Ejecuta query
   ResultSet rs = pstmt.executeQuery();

5. SQL Server procesa el WHERE y retorna filas filtradas
   Solo filas donde type = 'ENTRADA'

6. while (rs.next()) recorre cada fila filtrada
   Crea objetos Movement y los agrega a la lista

7. Retorna la lista completa
   Main.java puede recorrerla e imprimirla
```

**â±ï¸ Tiempo estimado:** 3-4 horas

---

## âœ… Checkpoint 4.3: Actualizar vehÃ­culos (`UPDATE`)

**Concepto clave:** Validar existencia previa y entender impacto de `WHERE` en UPDATE.

**ğŸ“ DÃ“NDE:** 
- Crear archivo `VehicleService.java` en `src/main/java/com/forestech/services/`

**ğŸ¯ PARA QUÃ‰:** 
Los datos cambian con el tiempo:
- **Corregir errores** en datos capturados
- **Actualizar informaciÃ³n** (ej: nuevo nÃºmero de placa)
- **Modificar estado** (ej: vehÃ­culo activo/inactivo)

Sin UPDATE, tendrÃ­as que eliminar y crear nuevamente (Â¡perdiendo historial!)

**ğŸ”— CONEXIÃ“N FUTURA:**
- En Fase 5, actualizarÃ¡s cantidades de inventario despuÃ©s de cada movimiento
- En Fase 6, el usuario podrÃ¡ editar datos desde el menÃº
- En Fase 7, validarÃ¡s permisos antes de permitir actualizaciones
- En Fase 8, registrarÃ¡s auditorÃ­a de quÃ© cambiÃ³

**Prompts sugeridos:**
```text
"Â¿QuÃ© pasa si hago UPDATE sin WHERE?"
"Â¿CÃ³mo verifico que el registro existe antes de actualizar?"
"Â¿QuÃ© significa que executeUpdate() retorne 0?"
```

**Tareas paso a paso:**

1. **Crear VehicleService:**
   - Similar a MovementService
   - MÃ©todos estÃ¡ticos por ahora

2. **Crear mÃ©todo `updateVehicle(String id, Vehicle vehicle)`:**
   - Recibe el id del vehÃ­culo a actualizar
   - Recibe el objeto Vehicle con los nuevos datos
   - Retorna boolean (true si actualizÃ³, false si no)

3. **Verificar existencia (IMPORTANTE):**
   - Antes de actualizar, ejecuta SELECT COUNT(*) WHERE id = ?
   - Si retorna 0, el vehÃ­culo no existe
   - Imprime mensaje y retorna false

4. **Construir query UPDATE:**
   - UPDATE combustibles_vehicles SET plate = ?, model = ?, category = ? WHERE id = ?
   - Usa placeholders para todos los valores

5. **Ejecutar UPDATE:**
   - Asigna valores con setString
   - Ejecuta executeUpdate()
   - Verifica filas afectadas (debe ser 1)

6. **Probar en Main.java:**
   - Inserta un vehÃ­culo
   - ModifÃ­calo con updateVehicle
   - Verifica en SQL Server que cambiÃ³
   - Intenta actualizar un id que no existe

**âœ… Resultado esperado:** 
- Actualizar vehÃ­culo existente exitosamente
- Rechazar actualizaciÃ³n si el id no existe
- Mensaje claro en ambos casos

**âš ï¸ PELIGRO:** UPDATE sin WHERE actualiza TODAS las filas. Siempre verifica tu query.

**ğŸ’¡ Buena prÃ¡ctica:** Imprime cuÃ¡ntos campos cambiaron (puedes comparar antes/despuÃ©s).

**â±ï¸ Tiempo estimado:** 2-3 horas

---

## âœ… Checkpoint 4.4: Eliminar con validaciÃ³n (`DELETE`)

**Concepto clave:** Preservar integridad referencial antes de eliminar.

**ğŸ“ DÃ“NDE:** 
- Clase `SupplierService` en nuevo archivo `SupplierService.java`
- O agregar mÃ©todo en MovementService

**ğŸ¯ PARA QUÃ‰:** 
Eliminar datos es PELIGROSO:
- **No se puede deshacer** fÃ¡cilmente
- **Puede romper relaciones** con otras tablas
- **Puede perder informaciÃ³n valiosa** para auditorÃ­a

Por eso necesitas validaciones estrictas.

**ğŸ”— CONEXIÃ“N FUTURA:**
- En Fase 5, implementarÃ¡s "soft delete" (marcar como inactivo en vez de borrar)
- En Fase 7, agregarÃ¡s confirmaciÃ³n del usuario antes de eliminar
- En Fase 8, registrarÃ¡s quiÃ©n eliminÃ³ y cuÃ¡ndo (auditorÃ­a)
- En Fase 9, los reportes solo mostrarÃ¡n registros activos

**Prompts sugeridos:**
```text
"ExplÃ­came integridad referencial y quÃ© podrÃ­a romperse si borro sin validar."
"Â¿QuÃ© es un DELETE en cascada y cuÃ¡ndo conviene usarlo?"
"Â¿QuÃ© es soft delete y cuÃ¡les son sus ventajas?"
```

**Tareas paso a paso:**

1. **Crear mÃ©todo `deleteSupplier(String id)`:**
   - Recibe el id del proveedor a eliminar
   - Retorna boolean

2. **Validar dependencias (CRÃTICO):**
   - Antes de borrar, consulta: SELECT COUNT(*) FROM combustibles_movements WHERE supplierId = ?
   - Si hay movimientos asociados, NO eliminar
   - Imprime mensaje: "No se puede eliminar, tiene X movimientos asociados"
   - Retorna false

3. **Si no hay dependencias:**
   - Construye query DELETE con WHERE id = ?
   - Ejecuta executeUpdate()
   - Verifica filas afectadas

4. **Considerar alternativa soft delete:**
   - En vez de DELETE, usa UPDATE para cambiar un campo isActive = false
   - Ventaja: conservas el historial

5. **Probar en Main.java:**
   - Intenta eliminar un proveedor CON movimientos (debe rechazar)
   - Intenta eliminar un proveedor SIN movimientos (debe permitir)
   - Verifica en SQL Server el resultado

**âœ… Resultado esperado:** 
- Proteger integridad de datos rechazando eliminaciones peligrosas
- Eliminar solo cuando es seguro
- Mensajes claros sobre por quÃ© se rechaza

**ğŸ’¡ ReflexiÃ³n:** Â¿QuÃ© es mejor para Forestech: DELETE real o soft delete? DiscÃºtelo con tu IA.

**â±ï¸ Tiempo estimado:** 2-3 horas

---

## ğŸ§ª Refuerzos de calidad

**Pruebas manuales tras cada operaciÃ³n:**
- Consulta la tabla en SQL Server para verificar estado
- Compara lo que ves en la BD con lo que esperabas
- Verifica conteo de filas antes y despuÃ©s

**Registro de aprendizaje:**
- Anota SQL ejecutado, filas afectadas y resultados esperados vs reales
- Documenta errores encontrados y cÃ³mo los resolviste
- Crea script `cleanup.sql` para restaurar datos de prueba

**Testing inicial:**
- Prepara tu primer test JUnit simple (aunque se conecte a BD real)
- Valida que insertar un Movement retorna true
- Valida que insertar con datos invÃ¡lidos retorna false

---

## âœ… Checklist de salida de Fase 4

- [ ] Domino PreparedStatement y sÃ© cÃ³mo evita SQL Injection
- [ ] Puedo explicar la diferencia entre executeQuery y executeUpdate
- [ ] Mis mÃ©todos INSERT guardan objetos Java en la BD correctamente
- [ ] Mis mÃ©todos SELECT retornan List<Objeto> correctamente mapeados
- [ ] Mis mÃ©todos UPDATE verifican existencia antes de actualizar
- [ ] Mis mÃ©todos DELETE validan integridad referencial antes de borrar
- [ ] Mis servicios retornan colecciones vacÃ­as en vez de null
- [ ] DocumentÃ© en JAVA_LEARNING_LOG.md decisiones, casos de prueba y aprendizajes

**ğŸ¯ DesafÃ­o final:** 
Crea un mÃ©todo `getMovementsByDateRange(String startDate, String endDate)` que retorne movimientos entre dos fechas.

**ğŸ“Š Tabla de mÃ©todos CRUD completados:**

| Servicio | CREATE | READ | UPDATE | DELETE |
|----------|--------|------|--------|--------|
| MovementService | âœ… | âœ… | âšª | âšª |
| VehicleService | âšª | âšª | âœ… | âšª |
| SupplierService | âšª | âšª | âšª | âœ… |

**Objetivo:** Completar todas las operaciones para al menos MovementService.

---

## ğŸš€ PrÃ³ximo paso: FASE 5 - LÃ³gica de Negocio

En la siguiente fase aprenderÃ¡s a:
- Implementar reglas de negocio (no permitir salidas mayores al inventario)
- Manejar transacciones (varias operaciones que deben ser atÃ³micas)
- Calcular inventario actual dinÃ¡micamente
- Validar datos antes de guardar
- Crear mÃ©todos de servicio mÃ¡s complejos

**Â¿Por quÃ© lÃ³gica de negocio?** Hasta ahora solo guardas/lees datos. La lÃ³gica de negocio asegura que los datos sean VÃLIDOS y CONSISTENTES segÃºn las reglas de Forestech (ej: no vender mÃ¡s combustible del que tienes).

**â±ï¸ Tiempo total Fase 4:** 10-15 horas distribuidas en 2 semanas
